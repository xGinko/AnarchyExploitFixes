package me.moomoo.anarchyexploitfixes.modules.patches;

import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.item.ItemStack;
import com.github.retrooper.packetevents.protocol.nbt.NBTCompound;
import com.github.retrooper.packetevents.protocol.nbt.NBTList;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSetSlot;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AEFModule;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class BeehiveCoordinates extends PacketListenerAbstract implements AEFModule {

    private final Set<String> entityDataTagsToRemove;

    public BeehiveCoordinates() {
        super(PacketListenerPriority.HIGHEST);
        Config config = AnarchyExploitFixes.getConfiguration();
        config.addComment("patches.remove-beehive-coordinates.enable",
                "Patches an exploit that allows players to obtain another player's coordinates\n" +
                "by trading them for beehives or beenests.\n" +
                "If the traded item contains any bees, the stored bee's NBT data could then be read from the item.\n" +
                "This data includes, but is not limited to:\n" +
                " - UID of the world the bee was first spawned into existence\n" +
                " - XYZ coordinates of where the bee was first spawned into existence\n" +
                " - XYZ coordinates of where the bee last visited a flower\n" +
                " - XYZ coordinates of where the bee has its hive\n" +
                " - XYZ of the bee's last coordinates before entering it's hive");
        this.entityDataTagsToRemove = new HashSet<>(config.getList("patches.remove-beehive-coordinates.tags", Arrays.asList(
                "Pos", "HivePos", "FlowerPos", "Paper.Origin", "Paper.OriginWorld", "WorldUUIDMost", "WorldUUIDLeast"),
                "The NBT tags to filter from the item. These are the Keys that hold the position data.\n" +
                "You may add more tags you want removed here."));
    }

    @Override
    public String name() {
        return "remove-beehive-coordinates";
    }

    @Override
    public String category() {
        return "patches";
    }

    @Override
    public void enable() {
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("patches.remove-beehive-coordinates.enable", true);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.getPacketType() == PacketType.Play.Server.SET_SLOT) {
            WrapperPlayServerSetSlot packet = new WrapperPlayServerSetSlot(event);
            ItemStack filtered = filterItemStack(packet.getItem());
            if (filtered != null) {
                packet.setItem(filtered);
                event.markForReEncode(true);
            }
        }
    }

    private ItemStack filterItemStack(ItemStack itemStack) {
        if (itemStack == null || itemStack.isEmpty()) return null;
        final NBTCompound rootCompound = itemStack.getNBT();
        if (rootCompound == null) return null;

        if (filterCompound(rootCompound)) {
            itemStack.setNBT(rootCompound);
            return itemStack;
        }

        return null;
    }

    private boolean filterCompound(NBTCompound compound) {
        if (compound == null || compound.isEmpty()) return false;

        boolean needsReEncode = false;

        if (compound.getTags().containsKey("Bees")) {
            NBTList<NBTCompound> bees = compound.getCompoundListTagOrNull("Bees");
            if (bees == null || bees.isEmpty()) return needsReEncode;

            for (int i = 0; i < bees.size(); i++) {
                NBTCompound beeEntity = bees.getTag(i);
                NBTCompound beeEntityData = beeEntity.getCompoundTagOrNull("EntityData");
                if (beeEntityData != null) {
                    for (String toRemove : entityDataTagsToRemove) {
                        if (beeEntityData.removeTag(toRemove) != null) {
                            needsReEncode = true;
                        }
                    }
                    if (needsReEncode)
                        beeEntity.setTag("EntityData", beeEntityData);
                }
                if (needsReEncode)
                    bees.setTag(i, beeEntity);
            }

            if (needsReEncode)
                compound.setTag("Bees", bees);
        }

        if (compound.getTags().containsKey("Items")) {
            NBTList<NBTCompound> items = compound.getCompoundListTagOrNull("Items");
            if (items == null || items.isEmpty()) return needsReEncode;

            for (int i = 0; i < items.size(); i++) {
                NBTCompound item = items.getTag(i);
                NBTCompound itemRootCompound = item.getCompoundTagOrNull("tag");
                if (filterCompound(itemRootCompound)) {
                    items.setTag(i, item);
                    needsReEncode = true;
                }
            }

            if (needsReEncode)
                compound.setTag("Items", items);
        }

        if (compound.getTags().containsKey("BlockEntityTag")) {
            NBTCompound blockEntityTag = compound.getCompoundTagOrNull("BlockEntityTag");
            if (filterCompound(blockEntityTag)) {
                compound.setTag("BlockEntityTag", blockEntityTag);
                needsReEncode = true;
            }
        }

        return needsReEncode;
    }
}
