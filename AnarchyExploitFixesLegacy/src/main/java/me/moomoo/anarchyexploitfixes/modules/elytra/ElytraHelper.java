package me.moomoo.anarchyexploitfixes.modules.elytra;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.util.Vector3d;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPlayerPosition;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPlayerPositionAndRotation;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.config.Config;
import me.moomoo.anarchyexploitfixes.modules.AEFModule;
import me.moomoo.anarchyexploitfixes.utils.LocationUtil;
import me.moomoo.anarchyexploitfixes.utils.models.ExpiringSet;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.Pair;
import org.bukkit.Chunk;
import org.bukkit.Location;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerMoveEvent;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.util.NumberConversions;

import java.time.Duration;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

public class ElytraHelper extends PacketListenerAbstract implements AEFModule, Listener {

    public static final double SPEED_TOLERANCE = 0.02;
    private static ElytraHelper instance;
    private final AnarchyExploitFixes plugin;
    private final Set<UUID> new_chunk_players;
    private final Cache<UUID, Double> updated_speed_average;
    private final Cache<UUID, ExpiringSet<Double>> speed_history;
    private final Cache<UUID, Pair<Vector3d, Long>> previous_positions;
    private final int serverViewDistance;
    private final boolean calculate3D;

    public ElytraHelper() {
        super(PacketListenerPriority.MONITOR);
        instance = this;
        this.plugin = AnarchyExploitFixes.getInstance();
        this.serverViewDistance = plugin.getServer().getViewDistance();
        this.calculate3D = AnarchyExploitFixes.getConfiguration().elytra_calculate_3D;
        this.new_chunk_players = new HashSet<>(Math.max(16, plugin.getServer().getOnlinePlayers().size()));
        this.speed_history = Caffeine.newBuilder().expireAfterWrite(Duration.ofMinutes(5)).build();
        this.previous_positions = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(5)).build();
        this.updated_speed_average = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(5)).build();
    }

    public static ElytraHelper getInstance() {
        return instance;
    }

    @Override
    public String name() {
        return "elytra-helper";
    }

    @Override
    public String category() {
        return "elytra";
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        PacketEvents.getAPI().getEventManager().registerListener(this);
    }

    @Override
    public boolean shouldEnable() {
        Config config = AnarchyExploitFixes.getConfiguration();
        return config.elytra_enable_at_spawn || config.elytra_enable_global || config.elytra_enable_netherceiling;
    }

    @Override
    public void onPacketReceive(PacketReceiveEvent event) {
        final Vector3d position;
        if (event.getPacketType() == PacketType.Play.Client.PLAYER_POSITION) {
            position = new WrapperPlayClientPlayerPosition(event).getPosition();
        } else if (event.getPacketType() == PacketType.Play.Client.PLAYER_POSITION_AND_ROTATION) {
            position = new WrapperPlayClientPlayerPositionAndRotation(event).getPosition();
        } else {
            return;
        }

        final Player player = (Player) event.getPlayer();
        if (!player.isGliding()) return;

        final Pair<Vector3d, Long> toPos = new Pair<>(position, System.currentTimeMillis());
        final Pair<Vector3d, Long> fromPos = previous_positions.get(player.getUniqueId(), k -> toPos);
        previous_positions.put(player.getUniqueId(), toPos);

        double distance;
        if (calculate3D) {
            distance = LocationUtil.getDistance3D(
                    position.x - fromPos.getKey().x,
                    position.y - fromPos.getKey().y,
                    position.z - fromPos.getKey().z);
        } else {
            distance = FastMath.hypot(
                    position.x - fromPos.getKey().x,
                    position.z - fromPos.getKey().z);
        }

        final double distancePerTicks = (distance / toPos.getValue() - fromPos.getValue()) * 50;
        if (distancePerTicks <= 0 || Double.isNaN(distancePerTicks) || Double.isInfinite(distancePerTicks)) return;

        final ExpiringSet<Double> speedCache = speed_history.get(player.getUniqueId(), k -> new ExpiringSet<>(Duration.ofSeconds(5)));
        speedCache.add(distancePerTicks);
        speed_history.put(player.getUniqueId(), speedCache);

        double sum = 0.0;
        for (Double recent : speedCache)
            sum += recent;

        updated_speed_average.put(player.getUniqueId(), sum / speedCache.asSet().size());
    }

    public Location getFrom(PlayerMoveEvent event) {
        final Pair<Vector3d, Long> from = previous_positions.getIfPresent(event.getPlayer().getUniqueId());
        return from == null ? event.getFrom() : new Location(event.getFrom().getWorld(), from.getKey().x, from.getKey().y, from.getKey().z);
    }

    public double getBlocksPerTick(PlayerMoveEvent event) {
        return updated_speed_average.get(event.getPlayer().getUniqueId(), uuid -> calculate3D ?
                LocationUtil.getRelDistance3D(event.getTo(), event.getFrom()) :
                LocationUtil.getRelDistance2D(event.getTo(), event.getFrom()));
    }

    public boolean isInNewChunks(Player player) {
        return new_chunk_players.contains(player.getUniqueId());
    }

    public int getViewDistance(Player player) {
        try {
            return player.getViewDistance();
        } catch (Exception e) {
            return serverViewDistance;
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    private void onChunkLoad(ChunkLoadEvent event) {
        for (Player player : event.getWorld().getPlayers()) {
            if (chunkDistanceSquared(event.getChunk(), player.getLocation()) < NumberConversions.square(getViewDistance(player))) {
                if (event.isNewChunk()) {
                    this.new_chunk_players.add(player.getUniqueId());
                } else {
                    this.new_chunk_players.remove(player.getUniqueId());
                }
            }
        }
    }

    /**
     * Since the distance here is only used to see whether a chunk is loaded roughly within the player's view distance,
     * we can resort to comparing squared distances.
     * This saves cpu usage as we don't have to use {@link Math#sqrt(double)} to get the accurate distance in chunks.
     */
    private static double chunkDistanceSquared(Chunk chunk, Location location) {
        return  NumberConversions.square(chunk.getX() - (location.getBlockX() >> 4)) +
                NumberConversions.square(chunk.getZ() - (location.getBlockZ() >> 4));
    }
}
