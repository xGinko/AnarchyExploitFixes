package me.moomoo.anarchyexploitfixes.modules.chunklimits;

import com.cryptomorin.xseries.XMaterial;
import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import me.moomoo.anarchyexploitfixes.modules.AnarchyExploitFixesModule;
import me.moomoo.anarchyexploitfixes.utils.ChunkUtil;
import me.moomoo.anarchyexploitfixes.utils.LogUtil;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPlaceEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;

public class BlockLimit implements AnarchyExploitFixesModule, Listener {

    private final Map<Material, Integer> blockLimits = new HashMap<>();

    public BlockLimit() {
        shouldEnable();

        Map<XMaterial, Integer> universal = new HashMap<>();
        // General items
        universal.put(XMaterial.ENCHANTING_TABLE, 16);
        universal.put(XMaterial.ENDER_CHEST, 64);
        universal.put(XMaterial.CHEST, 500);
        universal.put(XMaterial.TRAPPED_CHEST, 200);
        universal.put(XMaterial.DISPENSER, 100);
        universal.put(XMaterial.SLIME_BLOCK, 128);
        universal.put(XMaterial.BEACON, 32);
        universal.put(XMaterial.PISTON, 32);
        universal.put(XMaterial.STICKY_PISTON, 32);
        universal.put(XMaterial.MOVING_PISTON, 32);
        universal.put(XMaterial.PISTON_HEAD, 32);
        universal.put(XMaterial.GLOWSTONE, 5000);
        // Skull items
        universal.put(XMaterial.CREEPER_HEAD, 16);
        universal.put(XMaterial.CREEPER_WALL_HEAD, 16);
        universal.put(XMaterial.DRAGON_HEAD, 16);
        universal.put(XMaterial.DRAGON_WALL_HEAD, 16);
        universal.put(XMaterial.PIGLIN_HEAD, 16);
        universal.put(XMaterial.PIGLIN_WALL_HEAD, 16);
        universal.put(XMaterial.PLAYER_HEAD, 16);
        universal.put(XMaterial.PLAYER_WALL_HEAD, 16);
        universal.put(XMaterial.ZOMBIE_HEAD, 16);
        universal.put(XMaterial.ZOMBIE_WALL_HEAD, 16);
        // Signs
        universal.put(XMaterial.ACACIA_HANGING_SIGN, 8);
        universal.put(XMaterial.ACACIA_SIGN, 8);
        universal.put(XMaterial.ACACIA_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.ACACIA_WALL_SIGN, 8);
        universal.put(XMaterial.BAMBOO_HANGING_SIGN, 8);
        universal.put(XMaterial.BAMBOO_SIGN, 8);
        universal.put(XMaterial.BAMBOO_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.BAMBOO_WALL_SIGN, 8);
        universal.put(XMaterial.BIRCH_HANGING_SIGN, 8);
        universal.put(XMaterial.BIRCH_SIGN, 8);
        universal.put(XMaterial.BIRCH_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.BIRCH_WALL_SIGN, 8);
        universal.put(XMaterial.CRIMSON_HANGING_SIGN, 8);
        universal.put(XMaterial.CRIMSON_SIGN, 8);
        universal.put(XMaterial.CRIMSON_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.CRIMSON_WALL_SIGN, 8);
        universal.put(XMaterial.DARK_OAK_HANGING_SIGN, 8);
        universal.put(XMaterial.DARK_OAK_SIGN, 8);
        universal.put(XMaterial.DARK_OAK_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.DARK_OAK_WALL_SIGN, 8);
        universal.put(XMaterial.JUNGLE_HANGING_SIGN, 8);
        universal.put(XMaterial.JUNGLE_SIGN, 8);
        universal.put(XMaterial.JUNGLE_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.JUNGLE_WALL_SIGN, 8);
        universal.put(XMaterial.MANGROVE_HANGING_SIGN, 8);
        universal.put(XMaterial.MANGROVE_SIGN, 8);
        universal.put(XMaterial.MANGROVE_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.MANGROVE_WALL_SIGN, 8);
        universal.put(XMaterial.OAK_HANGING_SIGN, 8);
        universal.put(XMaterial.OAK_SIGN, 8);
        universal.put(XMaterial.OAK_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.OAK_WALL_SIGN, 8);
        universal.put(XMaterial.SPRUCE_HANGING_SIGN, 8);
        universal.put(XMaterial.SPRUCE_SIGN, 8);
        universal.put(XMaterial.SPRUCE_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.SPRUCE_WALL_SIGN, 8);
        universal.put(XMaterial.WARPED_HANGING_SIGN, 8);
        universal.put(XMaterial.WARPED_SIGN, 8);
        universal.put(XMaterial.WARPED_WALL_HANGING_SIGN, 8);
        universal.put(XMaterial.WARPED_WALL_SIGN, 8);
        // Banners
        universal.put(XMaterial.BLACK_BANNER, 12);
        universal.put(XMaterial.BLACK_WALL_BANNER, 12);
        universal.put(XMaterial.BLUE_BANNER, 12);
        universal.put(XMaterial.BLUE_WALL_BANNER, 12);
        universal.put(XMaterial.BROWN_BANNER, 12);
        universal.put(XMaterial.BROWN_WALL_BANNER, 12);
        universal.put(XMaterial.CYAN_BANNER, 12);
        universal.put(XMaterial.CYAN_WALL_BANNER, 12);
        universal.put(XMaterial.GRAY_BANNER, 12);
        universal.put(XMaterial.GRAY_WALL_BANNER, 12);
        universal.put(XMaterial.GREEN_BANNER, 12);
        universal.put(XMaterial.GREEN_WALL_BANNER, 12);
        universal.put(XMaterial.LIGHT_BLUE_BANNER, 12);
        universal.put(XMaterial.LIGHT_BLUE_WALL_BANNER, 12);
        universal.put(XMaterial.LIGHT_GRAY_BANNER, 12);
        universal.put(XMaterial.LIGHT_GRAY_WALL_BANNER, 12);
        universal.put(XMaterial.LIME_BANNER, 12);
        universal.put(XMaterial.LIME_WALL_BANNER, 12);
        universal.put(XMaterial.MAGENTA_BANNER, 12);
        universal.put(XMaterial.MAGENTA_WALL_BANNER, 12);
        universal.put(XMaterial.ORANGE_BANNER, 12);
        universal.put(XMaterial.ORANGE_WALL_BANNER, 12);
        universal.put(XMaterial.PINK_BANNER, 12);
        universal.put(XMaterial.PINK_WALL_BANNER, 12);
        universal.put(XMaterial.PURPLE_BANNER, 12);
        universal.put(XMaterial.PURPLE_WALL_BANNER, 12);
        universal.put(XMaterial.RED_BANNER, 12);
        universal.put(XMaterial.RED_WALL_BANNER, 12);
        universal.put(XMaterial.YELLOW_BANNER, 12);
        universal.put(XMaterial.YELLOW_WALL_BANNER, 12);

        Map<String, Object> compatible = new HashMap<>();
        for (Map.Entry<XMaterial, Integer> entry : universal.entrySet()) {
            if (entry.getKey().isSupported()) {
                compatible.put(entry.getKey().parseMaterial().name(), entry.getValue());
            }
        }

        ConfigSection section = AnarchyExploitFixes.getConfiguration().getConfigSection("chunk-limits.block-limit.max-blocks-per-chunk", compatible,
                "Attempt to prevent ChunkBan / Client FPS Lag");
        for (String configuredMaterial : section.getKeys(false)) {
            try {
                Material blockMaterial = Material.valueOf(configuredMaterial);
                Integer maxAmountPerChunk = Integer.valueOf(section.getString(configuredMaterial));
                blockLimits.put(blockMaterial, maxAmountPerChunk);
            } catch (NumberFormatException e) {
                LogUtil.integerNotRecognized(Level.WARNING, name(), configuredMaterial);
            } catch (IllegalArgumentException e) {
                LogUtil.materialNotRecognized(Level.WARNING, name(), configuredMaterial);
            }
        }
    }

    @Override
    public String name() {
        return "block-limit";
    }

    @Override
    public String category() {
        return "chunk-limits";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.getConfiguration().getBoolean("chunk-limits.block-limit.enable", false) && !blockLimits.isEmpty();
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBlockPlace(BlockPlaceEvent event) {
        final Material placedType = event.getBlock().getType();
        if (
                blockLimits.containsKey(placedType)
                && exceedsPerChunkLimit(placedType, blockLimits.get(placedType), event.getBlock().getChunk())
        ) {
            event.setCancelled(true);
        }
    }

    private boolean exceedsPerChunkLimit(Material material, int limit, Chunk chunk) {
        final int minY = ChunkUtil.guessMinWorldHeight(chunk.getWorld());
        final int maxY = chunk.getWorld().getMaxHeight();
        int count = 0;
        for (int x = 0; x < 16; x++) {
            for (int z = 0; z < 16; z++) {
                for (int y = minY; y < maxY; y++) {
                    if (chunk.getBlock(x, y, z).getType() == material) {
                        count++;
                        if (count > limit) return true;
                    }
                }
            }
        }
        return false;
    }
}
