package me.moomoo.anarchyexploitfixes.utils;

import com.cryptomorin.xseries.XMaterial;
import com.cryptomorin.xseries.XTag;
import org.bukkit.Material;
import org.bukkit.inventory.ItemStack;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class MaterialUtil {

    // Blocks that the player gets lowered into slightly when walking on them
    public static final Set<Material> SINK_IN_BLOCKS = Stream.of(
                    XMaterial.SOUL_SAND,
                    XMaterial.FARMLAND,
                    XMaterial.MUD
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> PLAYER_HEADS = Stream.of(
            XMaterial.PLAYER_HEAD,
            XMaterial.PLAYER_WALL_HEAD
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> INDESTRUCTIBLES = Stream.of(
            XMaterial.BEDROCK,
            XMaterial.END_PORTAL_FRAME,
            XMaterial.END_PORTAL,
            XMaterial.REINFORCED_DEEPSLATE,
            XMaterial.STRUCTURE_BLOCK,
            XMaterial.STRUCTURE_VOID,
            XMaterial.BARRIER,
            XMaterial.COMMAND_BLOCK
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> SOLID_INDESTRUCTIBLES = Stream.of(
            XMaterial.BEDROCK,
            XMaterial.END_PORTAL_FRAME,
            XMaterial.REINFORCED_DEEPSLATE,
            XMaterial.STRUCTURE_BLOCK,
            XMaterial.STRUCTURE_VOID,
            XMaterial.BARRIER,
            XMaterial.COMMAND_BLOCK
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> BOOKS = Stream.of(
            XMaterial.WRITABLE_BOOK,
            XMaterial.WRITTEN_BOOK
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> SHULKER_BOXES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("SHULKER_BOX") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static boolean isShulkerBox(ItemStack item) {
        if (item == null) return false;
        return SHULKER_BOXES.contains(item.getType());
    }

    public static final Set<Material> HELMETS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_HELMET") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> CHESTPLATES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_CHESTPLATE") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> LEGGINGS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_LEGGINGS") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> BOOTS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_BOOTS") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> AXES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_AXE") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> HOES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_HOE") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> PICKAXES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_PICKAXE") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> SHOVELS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SHOVEL") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> SWORDS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SWORD") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> SIGNS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SIGN") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> PISTONS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("PISTON") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> TRAPDOORS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_TRAPDOOR") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> ANVILS = XTag.ANVIL.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> BLOCK_DISPENSE_BUCKETS = Stream.of(
                    XMaterial.WATER_BUCKET,
                    XMaterial.LAVA_BUCKET,
                    XMaterial.COD_BUCKET,
                    XMaterial.SALMON_BUCKET,
                    XMaterial.PUFFERFISH_BUCKET,
                    XMaterial.TROPICAL_FISH_BUCKET,
                    XMaterial.AXOLOTL_BUCKET,
                    XMaterial.TADPOLE_BUCKET,
                    XMaterial.POWDER_SNOW_BUCKET
            ).filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static final Set<Material> SPAWN_EGGS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SPAWN_EGG") && xMaterial.isSupported())
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(HashSet::new));

    public static boolean isSpawnEgg(ItemStack item) {
        if (item == null) return false;
        return SPAWN_EGGS.contains(item.getType());
    }

    public static boolean isArmor(ItemStack item) {
        if (item == null) return false;
        return isArmor(item.getType());
    }

    public static boolean isArmor(Material material) {
        if (material == null) return false;
        return HELMETS.contains(material) || CHESTPLATES.contains(material) || LEGGINGS.contains(material) || BOOTS.contains(material);
    }

    public static boolean isTool(ItemStack item) {
        if (item == null) return false;
        return isTool(item.getType());
    }

    public static boolean isTool(Material material) {
        if (material == null) return false;
        return AXES.contains(material) || HOES.contains(material) || PICKAXES.contains(material) || SHOVELS.contains(material);
    }

    private static final Material ELYTRA = XMaterial.ELYTRA.parseMaterial();
    public static boolean isElytra(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(ELYTRA);
    }

    private static final Material TRIDENT = XMaterial.TRIDENT.parseMaterial();
    public static boolean isTrident(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(TRIDENT);
    }

    private static final Material CROSSBOW = XMaterial.CROSSBOW.parseMaterial();
    public static boolean isCrossbow(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(CROSSBOW);
    }

    private static final Material BOW = XMaterial.BOW.parseMaterial();
    public static boolean isBow(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(BOW);
    }

    private static final Material BUNDLE = XMaterial.BUNDLE.parseMaterial();
    public static boolean isBundle(ItemStack item) {
        if (item == null) return false;
        return item.getType().equals(BUNDLE);
    }
}