package me.moomoo.anarchyexploitfixes.utils;

import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import org.apache.commons.math3.util.FastMath;
import org.bukkit.Location;
import org.bukkit.World;

public class LocationUtil {

    public static boolean isNetherCeiling(Location location) {
        return location.getWorld().getEnvironment() == World.Environment.NETHER
                && location.getY() > AnarchyExploitFixes.getConfiguration().nether_ceiling_max_y;
    }

    public static double getDistance2DTo00(Location location) {
        return FastMath.hypot(location.getX(), location.getZ());
    }

    public static double getRelDistance2D(Location from, Location to) {
        double toX = to.getX();
        double toZ = to.getZ();
        double fromX = from.getX();
        double fromZ = from.getZ();

        final World.Environment toEnv = to.getWorld().getEnvironment();
        final World.Environment fromEnv = from.getWorld().getEnvironment();
        if (toEnv != fromEnv) {
            if (fromEnv == World.Environment.NETHER) {
                fromX *= 8;
                fromZ *= 8;
            }
            if (toEnv == World.Environment.NETHER) {
                toX *= 8;
                toZ *= 8;
            }
        }

        return FastMath.hypot(toX - fromX, toZ - fromZ);
    }

    public static double getRelDistance3D(Location from, Location to) {
        double toX = to.getX();
        double toZ = to.getZ();
        double fromX = from.getX();
        double fromZ = from.getZ();

        final World.Environment toEnv = to.getWorld().getEnvironment();
        final World.Environment fromEnv = from.getWorld().getEnvironment();
        if (toEnv != fromEnv) {
            if (fromEnv == World.Environment.NETHER) {
                fromX *= 8;
                fromZ *= 8;
            }
            if (toEnv == World.Environment.NETHER) {
                toX *= 8;
                toZ *= 8;
            }
        }

        return getDistance3D(fromX - toX, from.getY() - to.getY(), fromZ - toZ);
    }

    /**
     * Returns the Euclidean distance of a triangle with sides {@code x}, {@code y} and {@code z}
     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>&nbsp;+<i>z</i><sup>2</sup>)<br/>
     * avoiding intermediate overflow or underflow.
     *
     * <ul>
     * <li> If any argument is infinite, then the result is positive infinity.</li>
     * <li> else, if any argument is NaN then the result is NaN.</li>
     * </ul>
     *
     * @param x a value
     * @param y a value
     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>&nbsp;+<i>z</i><sup>2</sup>)<br/>
     */
    public static double getDistance3D(final double x, final double y, final double z) {
        if (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z)) {
            return Double.POSITIVE_INFINITY;
        } else if (Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z)) {
            return Double.NaN;
        } else {
            final int expX = FastMath.getExponent(x);
            final int expY = FastMath.getExponent(y);
            final int expZ = FastMath.getExponent(z);

            if (expX > expY + 27 && expX > expZ + 27) {
                // x is neglectible with respect to y and z
                return FastMath.abs(y) + FastMath.abs(z);
            } else if (expY > expX + 27 && expY > expZ + 27) {
                // y is neglectible with respect to x and z
                return FastMath.abs(x) + FastMath.abs(z);
            } else if (expZ > expX + 27 && expZ > expY + 27) {
                // z is neglectible with respect to x and y
                return FastMath.abs(x) + FastMath.abs(y);
            } else {
                final int middleExp = (expX + expY + expZ) / 3;

                final double scaledX = FastMath.scalb(x, -middleExp);
                final double scaledY = FastMath.scalb(y, -middleExp);
                final double scaledZ = FastMath.scalb(z, -middleExp);

                final double scaledH = Math.sqrt(scaledX * scaledX + scaledY * scaledY + scaledZ * scaledZ);

                return FastMath.scalb(scaledH, middleExp);
            }
        }
    }
}
