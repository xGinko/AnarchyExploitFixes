package me.xginko.aef.modules.lagpreventions;

import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.ChunkUtil;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.WorldUtil;
import me.xginko.aef.utils.models.ChunkUID;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.BlockState;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.util.NumberConversions;

import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 *  Credits to the initial idea of just keeping big chunks loaded to reduce lag
 *  created from loading them go to kumori (Soft1k) of 3b3t.org.
 */
public class KeepStashLoaded extends AEFModule implements Runnable, Listener {

    private final Map<ChunkUID, Long> forceLoadedChunks;
    private final Map<String, Double> worldsAndTheirRadiuses = new HashMap<>();
    private final Set<Material> storageTypes;
    private final long keepLoadedMillis, checkDelayTicks;
    private final int stashCount;
    private final boolean logIsEnabled, onlyTileEntities;

    public KeepStashLoaded() {
        super("lag-preventions.keep-stash-chunks-loaded");
        this.forceLoadedChunks = new ConcurrentHashMap<>();
        config.addComment(configPath + ".enable",
                "Idea by 3b3t admin kumori (Soft1k)\n"+
                "Improves lag generated by large stash chunks constantly loading and\n"+
                "unloading by setting them force loaded. This might cause increased ram\n"+
                "usage, so keep an eye out for that.\n" +
                "Only works on 1.15+. Will not enable on unsupported versions.");
        this.logIsEnabled = config.getBoolean(configPath + ".log", false);
        this.stashCount = config.getInt(configPath + ".container-block-threshold", 50,
                "How many container blocks have to be in a chunk for it to be seen\n"+
                "as a stash chunk to keep force loaded.");
        this.checkDelayTicks = config.getInt(configPath + ".check-delay-ticks", 200,
                "Ticks to wait after a chunk is loaded before it will be checked.\n" +
                "Reduces lag by fast travelling players.");
        this.keepLoadedMillis = TimeUnit.MINUTES.toMillis(config.getInt(configPath + ".keep-loaded-minutes", 120,
                "The time in minutes a stash chunks will be kept force loaded before\n"+
                "setting it back to normal."));
        this.onlyTileEntities = config.getBoolean(configPath + ".only-check-tile-entities", true,
                "Set to false if you want to check more blocks than just tile entities.\n" +
                        "Makes the overall speed of the module faster if set to true.");
        this.storageTypes = config.getList(configPath + ".container-types", MaterialUtil.INVENTORY_HOLDERS
                        .stream()
                        .map(Enum::name)
                        .collect(Collectors.toList()))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

        Map<String, Object> defaults = new HashMap<>();
        defaults.put("world", 100);
        defaults.put("world_nether", 100);
        defaults.put("world_the_end", 100);
        ConfigSection section = config.getConfigSection(configPath + ".worlds", defaults,
                "Radiuses around spawn in chunks (not blocks) that should not be checked.\n" +
                        "Worlds not on this list are exempt from all checking.");
        for (String world : section.getKeys(false)) {
            try {
                int radius = Integer.parseInt(section.getString(world));
                this.worldsAndTheirRadiuses.put(world, NumberConversions.square(radius));
            } catch (NumberFormatException e) {
                warn("Radius for world '" + world + "' is not a valid integer.");
            }
        }
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        plugin.getServer().getScheduler().runTaskTimerAsynchronously(plugin, this, 1L, 20L);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            entry.getKey().getChunkAsync(false).thenAccept(chunk -> {
                if (chunk != null)
                    ChunkUtil.setForceLoaded(chunk, false);
                forceLoadedChunks.remove(entry.getKey());
            });
        }
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false) && ChunkUtil.canSetChunksForceLoaded();
    }

    @Override
    public void run() {
        for (Map.Entry<ChunkUID, Long> entry : forceLoadedChunks.entrySet()) {
            if (System.currentTimeMillis() < entry.getValue()) {
                continue;
            }

            entry.getKey().getChunkAsync(false).thenAccept(chunk -> {
                if (chunk == null) {
                    forceLoadedChunks.remove(entry.getKey());
                    if (logIsEnabled)
                        info("Removing key that returns a null chunk: "+entry.getKey()+".");
                    return;
                }

                ChunkUtil.setForceLoaded(chunk, false);
                forceLoadedChunks.remove(entry.getKey());
                if (logIsEnabled)
                    info("Set chunk "+entry.getKey()+" to no longer force loaded.");
            });
        }
    }

    @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)
    private void onChunkLoad(ChunkLoadEvent event) {
        if (event.isNewChunk()) return;
        final String world = event.getWorld().getName();
        if (!worldsAndTheirRadiuses.containsKey(world)) return;

        Chunk chunk = event.getChunk();

        if (NumberConversions.square(chunk.getX()) + NumberConversions.square(chunk.getZ()) < worldsAndTheirRadiuses.get(world)) return;

        plugin.getServer().getScheduler().scheduleSyncDelayedTask(plugin, () -> {
            if (!chunk.isLoaded()) return;

            int count = 0;

            if (onlyTileEntities) {
                for (BlockState tileEntity : chunk.getTileEntities()) {
                    if (storageTypes.contains(tileEntity.getType())) {
                        count++;
                        if (count > stashCount) {
                            ChunkUtil.setForceLoaded(chunk, true);
                            forceLoadedChunks.computeIfAbsent(ChunkUID.of(chunk), chunkUID -> {
                                if (logIsEnabled) info("Set chunk " + chunkUID + " to force loaded.");
                                return System.currentTimeMillis() + keepLoadedMillis;
                            });
                            return;
                        }
                    }
                }
                return;
            }

            final int minY = WorldUtil.getMinWorldHeight(chunk.getWorld());
            final int maxY = chunk.getWorld().getMaxHeight();

            for (int x = 0; x < 16; x++) {
                for (int z = 0; z < 16; z++) {
                    for (int y = minY; y < maxY; y++) {
                        if (storageTypes.contains(chunk.getBlock(x, y, z).getType())) {
                            count++;
                            if (count > stashCount) {
                                ChunkUtil.setForceLoaded(chunk, true);
                                forceLoadedChunks.computeIfAbsent(ChunkUID.of(chunk), chunkUID -> {
                                    if (logIsEnabled) info("Set chunk " + chunkUID + " to force loaded.");
                                    return System.currentTimeMillis() + keepLoadedMillis;
                                });
                                return;
                            }
                        }
                    }
                }
            }
        }, checkDelayTicks);
    }
}
