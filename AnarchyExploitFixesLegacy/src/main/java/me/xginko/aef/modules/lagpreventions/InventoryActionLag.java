package me.xginko.aef.modules.lagpreventions;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.github.thatsmusic99.configurationmaster.api.ConfigSection;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.config.Config;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import org.bukkit.Location;
import org.bukkit.block.Block;
import org.bukkit.entity.Entity;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.inventory.InventoryAction;
import org.bukkit.event.inventory.InventoryClickEvent;

import java.time.Duration;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

public class InventoryActionLag implements AEFModule, Listener {

    private final Map<InventoryAction, Integer> clickActionLimits = new EnumMap<>(InventoryAction.class);
    private final Cache<UUID, Map<InventoryAction, Integer>> entityInventoryClicks;
    private final Cache<Location, Map<InventoryAction, Integer>> blockInventoryClicks;
    private final boolean logIsEnabled;

    public InventoryActionLag() {
        shouldEnable();
        Config config = AnarchyExploitFixes.config();
        config.addComment(configPath() + ".enable",
                "Prevent lag generated by players quickly moving big items back and forth between inventories.\n" +
                "Uses cached counters that auto-reset after the configurable time in milliseconds.");
        this.logIsEnabled = config.getBoolean(configPath() + ".log", true);
        Duration cacheTime = Duration.ofMillis(Math.max(config.getInt(configPath() + ".cache-time-millis", 2000,
                "The amount of time in milliseconds an entry is kept after writing."), 1));
        this.blockInventoryClicks = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        this.entityInventoryClicks = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        Map<String, Object> defaults = new HashMap<>();
        defaults.put("COLLECT_TO_CURSOR", 15);
        defaults.put("MOVE_TO_OTHER_INVENTORY", 8);
        defaults.put("HOTBAR_SWAP", 30);
        ConfigSection section = config.getConfigSection(configPath() + ".click-action-limits", defaults,
                "Use correct enums from: https://jd.papermc.io/paper/1.12/org/bukkit/event/inventory/InventoryAction.html.\n" +
                        "Format is: InventoryClickAction: AllowedClicksPerTime");
        for (String configuredAction : section.getKeys(false)) {
            try {
                InventoryAction action = InventoryAction.valueOf(configuredAction);
                Integer maxClicksPerTime = Integer.valueOf(section.getString(configuredAction));
                clickActionLimits.put(action, maxClicksPerTime);
            } catch (NumberFormatException e) {
                notRecognized(Integer.class, configuredAction);
            } catch (IllegalArgumentException e) {
                notRecognized(InventoryAction.class, configuredAction);
            }
        }
    }

    @Override
    public String configPath() {
        return "lag-preventions.prevent-inventory-action-lag";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.config().getBoolean(configPath() + ".enable", false);
    }

    @EventHandler(priority = EventPriority.LOW, ignoreCancelled = true)
    private void onInventoryClick(InventoryClickEvent event) {
        if (!clickActionLimits.containsKey(event.getAction())) return;
        if (event.getInventory().getHolder() == null) return;

        if (event.getInventory().getHolder() instanceof Block) {
            Block block = (Block) event.getInventory().getHolder();
            Map<InventoryAction, Integer> recordedClicks = blockInventoryClicks.get(block.getLocation(),
                    k -> new EnumMap<>(InventoryAction.class));
            Integer clickActionCounter = recordedClicks.getOrDefault(event.getAction(), 0);

            clickActionCounter++;

            if (clickActionCounter > clickActionLimits.get(event.getAction())) {
                event.setCancelled(true);
                if (logIsEnabled) info("Cancelled spammy inventory click of type " + event.getAction().name() + " at " +
                        LocationUtil.toString(block.getLocation()));
            }

            recordedClicks.put(event.getAction(), clickActionCounter);
            blockInventoryClicks.put(block.getLocation(), recordedClicks);

            return;
        }

        if (event.getInventory().getHolder() instanceof Entity) {
            Entity entity = (Entity) event.getInventory().getHolder();
            Map<InventoryAction, Integer> recordedClicks = entityInventoryClicks.get(entity.getUniqueId(),
                    k -> new EnumMap<>(InventoryAction.class));
            Integer clickActionCounter = recordedClicks.getOrDefault(event.getAction(), 0);

            clickActionCounter++;

            if (clickActionCounter > clickActionLimits.get(event.getAction())) {
                event.setCancelled(true);
                if (logIsEnabled) info("Cancelled spammy inventory click of type " + event.getAction().name()
                        + " at " + LocationUtil.toString(entity.getLocation()));
            }

            recordedClicks.put(event.getAction(), clickActionCounter);
            entityInventoryClicks.put(entity.getUniqueId(), recordedClicks);
        }
    }
}