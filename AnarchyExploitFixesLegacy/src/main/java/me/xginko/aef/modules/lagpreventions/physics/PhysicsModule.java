package me.xginko.aef.modules.lagpreventions.physics;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.models.BlockRegion2D;
import me.xginko.aef.utils.models.Disableable;
import org.bukkit.Location;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

public abstract class PhysicsModule extends AEFModule implements Disableable, Listener {

    protected final Cache<BlockRegion2D, RegionData> regionDataCache;
    protected final long pauseTimeMillis;
    protected final double checkRadius, pauseTPS, pauseMSPT;
    protected final boolean logIsEnabled;

    public PhysicsModule(String configPath) {
        super("lag-preventions.physics."+configPath);
        this.logIsEnabled = config.getBoolean("lag-preventions.physics."+configPath + ".log", false);
        this.checkRadius = config.getDouble("lag-preventions.physics."+configPath + ".check-radius-blocks", 1500.0,
                "The radius in blocks in which activity will be grouped together and measured.");
        this.pauseTimeMillis = config.getInt("lag-preventions.physics."+configPath + ".pause-time-millis", 5000,
                "The time in milliseconds all related activity will be blocked if it exceeded\n" +
                        "the configured limit.");
        this.regionDataCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                config.getInt("lag-preventions.physics."+configPath + ".data-keep-time-millis", 8000,
                        "The time in milliseconds before a region and its data will be expired\n" +
                                "if no activity has been detected.\n" +
                                "For proper functionality, needs to be at least as long as your pause time."))).build();
        this.pauseTPS = config.getDouble("lag-preventions.physics."+configPath + ".pause-TPS", 16.0,
                "The TPS at which to cancel the physics entirely.");
        this.pauseMSPT = config.getDouble("lag-preventions.physics."+configPath + ".pause-MSPT", 100.0,
                "The MSPT at which to cancel the physics entirely.");
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        regionDataCache.invalidateAll();
        regionDataCache.cleanUp();
    }

    protected @NotNull PhysicsModule.RegionData getRegionData(Location location) {
        return regionDataCache.get(getRegion(location), RegionData::new);
    }

    protected @NotNull BlockRegion2D getRegion(Location location) {
        for (Map.Entry<BlockRegion2D, RegionData> entry : regionDataCache.asMap().entrySet()) {
            if (entry.getKey().contains(location)) {
                regionDataCache.put(entry.getKey(), entry.getValue()); // Prevent data from expiring if it is continuously accessed
                return entry.getKey();
            }
        }
        BlockRegion2D region = BlockRegion2D.of(location.getWorld(), location.getX(), location.getZ(), checkRadius);
        regionDataCache.put(region, new RegionData(region)); // Cache freshly created region for future use
        return region;
    }

    protected void onLimitExceeded(Location location, RegionData regionData, int limit) {
        regionData.resumeTime.set(System.currentTimeMillis() + pauseTimeMillis);
        if (logIsEnabled) {
            info(   "Cancelling activity in a radius of " + checkRadius + " blocks from center at " +
                    "x=" + regionData.region.getCenterX() + ", z=" + regionData.region.getCenterZ() +
                    " in world " + location.getWorld().getName() + " for " + pauseTimeMillis + "ms, " +
                    "because of too high activity within the configured timeframe: " +
                    regionData.activityCount + " (limit: " + limit + ")");
        }
        regionData.activityCount.set(0); // Reset count when region is cooling down
    }

    protected boolean isCriticallyLagging() {
        return AnarchyExploitFixes.getTickReporter().getTPS() <= pauseTPS || AnarchyExploitFixes.getTickReporter().getMSPT() >= pauseMSPT;
    }

    protected void onLagExceeded(Event event) {
        if (logIsEnabled) info("Cancelled " + event.getClass().getSimpleName() + " because server is lagging.");
    }

    protected static class RegionData {

        public final BlockRegion2D region;
        public final AtomicLong resumeTime;
        public final AtomicInteger activityCount;

        public RegionData(BlockRegion2D region) {
            this.region = region;
            this.activityCount = new AtomicInteger(0);
            this.resumeTime = new AtomicLong(0L);
        }
    }
}
