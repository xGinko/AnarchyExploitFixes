package me.xginko.aef.modules.packets;

import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientPluginMessage;
import com.google.common.io.ByteStreams;
import me.xginko.aef.utils.PlatformUtil;
import org.bukkit.Location;
import org.bukkit.entity.Entity;
import org.bukkit.util.NumberConversions;

public class PurpurBeehiveCrash extends PacketModule {

    private static final int SIZE_BITS_X = 26;
    private static final int SIZE_BITS_Z = SIZE_BITS_X;
    private static final int SIZE_BITS_Y = 64 - SIZE_BITS_X - SIZE_BITS_Z;
    private static final int BIT_SHIFT_Z = SIZE_BITS_Y;
    private static final int BIT_SHIFT_X = SIZE_BITS_Y + SIZE_BITS_Z;

    private final String beehive_c2s_channel;
    private final double maxDistanceSquared;
    private final boolean log, kick;

    public PurpurBeehiveCrash() {
        super("patches.beehive-crash-patch", PacketListenerPriority.HIGHEST);
        config.addComment(configPath + ".enable",
                "Patches a server crash exploit exclusive to Purpur servers.\n" +
                "This exploit works due to PurpurClient having a feature that\n" +
                "lets clients request stored data of a clicked beehive from\n" +
                "the server. The server does not check how far the clicked\n" +
                "beehive is away from the client enabling a malicious sender\n" +
                "to load chunks very fast at far away locations by telling\n" +
                "the server it clicked a beehive there.");
        this.beehive_c2s_channel = config.getString(configPath + ".channel", "purpur:beehive_c2s");
        this.maxDistanceSquared = NumberConversions.square(config.getInt(configPath + ".max-distance", 24));
        this.log = config.getBoolean(configPath + ".log", false);
        this.kick = config.getBoolean(configPath + ".kick-player", false);
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", PlatformUtil.isPurpur());
    }

    @Override
    @SuppressWarnings("UnstableApiUsage")
    public void onPacketReceive(PacketReceiveEvent event) {
        if (event.isCancelled()) return;
        if (event.getPacketType() != PacketType.Play.Client.PLUGIN_MESSAGE) return;
        if (event.getPlayer() == null) return;

        WrapperPlayClientPluginMessage packet = new WrapperPlayClientPluginMessage(event);
        if (!packet.getChannelName().equalsIgnoreCase(beehive_c2s_channel)) return;

        if (distanceSquared(ByteStreams.newDataInput(packet.getData()).readLong(), ((Entity) event.getPlayer()).getLocation()) > maxDistanceSquared) {
            event.setCancelled(true);
            onCancel(log, kick, event.getUser());
        }
    }

    private double distanceSquared(long packedBlockPos, final Location playerPos) {
        return  NumberConversions.square(unpackLongX(packedBlockPos) - playerPos.getX()) +
                NumberConversions.square(unpackLongY(packedBlockPos) - playerPos.getY()) +
                NumberConversions.square(unpackLongZ(packedBlockPos) - playerPos.getZ());
    }

    private int unpackLongX(long packedPos) {
        return (int)(packedPos << 64 - BIT_SHIFT_X - SIZE_BITS_X >> 64 - SIZE_BITS_X);
    }

    private int unpackLongY(long packedPos) {
        return (int)(packedPos << 64 - SIZE_BITS_Y >> 64 - SIZE_BITS_Y);
    }

    private int unpackLongZ(long packedPos) {
        return (int)(packedPos << 64 - BIT_SHIFT_Z - SIZE_BITS_Z >> 64 - SIZE_BITS_Z);
    }
}
