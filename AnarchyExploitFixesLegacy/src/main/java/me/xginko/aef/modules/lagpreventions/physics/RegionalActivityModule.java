package me.xginko.aef.modules.lagpreventions.physics;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.models.BlockRegion2D;
import org.bukkit.Location;
import org.bukkit.event.Event;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 *  Credits to the initial idea of measuring burst activity within a certain region
 *  of the world go to kumori (Soft1k) of 3b3t.org.
 */
public abstract class RegionalActivityModule extends AEFModule implements Listener {

    protected final Cache<BlockRegion2D, RegionData> regionDataCache;
    protected final long pauseTimeMillis;
    protected final double checkRadius, pauseTPS, pauseMSPT;
    protected final boolean logIsEnabled;

    public RegionalActivityModule(
            String subConfigPath, boolean deflogEnabled, double defCheckRadius,
            int defPauseMillis, int defCacheMillis, double defPauseTPS, double defPauseMSPT
    ) {
        super("lag-preventions.regional-activity."+subConfigPath);
        String configPath = "lag-preventions.regional-activity."+subConfigPath;
        this.logIsEnabled = config.getBoolean(configPath + ".log", deflogEnabled);
        this.checkRadius = config.getDouble(configPath + ".check-radius-blocks", defCheckRadius,
                "The radius in blocks in which activity will be grouped together and measured.");
        this.pauseTimeMillis = config.getInt(configPath + ".pause-time-millis", defPauseMillis,
                "The time in milliseconds all related activity will be blocked if it exceeded\n" +
                        "the configured limit.");
        this.regionDataCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(
                config.getInt(configPath + ".data-keep-time-millis", defCacheMillis,
                        "The time in milliseconds before a region and its data will be expired\n" +
                                "if no activity has been detected.\n" +
                                "For proper functionality, needs to be at least as long as your pause time."))).build();
        this.pauseTPS = config.getDouble(configPath + ".pause-TPS", defPauseTPS,
                "The TPS at which to cancel the physics entirely.");
        this.pauseMSPT = config.getDouble(configPath + ".pause-MSPT", defPauseMSPT,
                "The MSPT at which to cancel the physics entirely.");
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        regionDataCache.invalidateAll();
    }

    @SuppressWarnings("DataFlowIssue")
    protected @NotNull RegionalActivityModule.RegionData getRegionData(Location location) {
        return regionDataCache.get(getRegion(location), RegionData::new);
    }

    protected @NotNull BlockRegion2D getRegion(Location location) {
        // Find and return region containing this location
        for (Map.Entry<BlockRegion2D, RegionData> regionDataEntry : regionDataCache.asMap().entrySet()) {
            if (regionDataEntry.getKey().contains(location)) {
                return regionDataEntry.getKey();
            }
        }
        // Create and cache region if none exists
        BlockRegion2D region = BlockRegion2D.of(location.getWorld(), location.getX(), location.getZ(), checkRadius);
        regionDataCache.put(region, new RegionData(region));
        return region;
    }

    protected void onLimitExceeded(Location location, RegionData regionData, int limit) {
        if (logIsEnabled) {
            info(   "Disabling in a radius of " + checkRadius + " blocks from center at " +
                    "x=" + regionData.region.getCenterX() + ", z=" + regionData.region.getCenterZ() +
                    " in world " + location.getWorld().getName() + " for " + pauseTimeMillis + "ms, " +
                    "because of too high activity within the configured timeframe: " +
                    regionData.activityCount + " (limit: " + limit + ")");
        }
        regionData.resumeTime.set(System.currentTimeMillis() + pauseTimeMillis);
        regionData.activityCount.set(0); // Reset count when region is cooling down
    }

    protected boolean isCriticallyLagging() {
        return AnarchyExploitFixes.getTickReporter().getTPS() <= pauseTPS || AnarchyExploitFixes.getTickReporter().getMSPT() >= pauseMSPT;
    }

    protected void onLagExceeded(Event event) {
        if (logIsEnabled) info("Cancelled " + event.getClass().getSimpleName() + " because server is lagging." +
                " (tps="+AnarchyExploitFixes.getTickReporter().getTPS()+" | mspt="+AnarchyExploitFixes.getTickReporter().getMSPT()+")");
    }

    protected static class RegionData {

        public final BlockRegion2D region;
        public final AtomicLong resumeTime;
        public final AtomicInteger activityCount;

        public RegionData(BlockRegion2D region) {
            this.region = region;
            this.activityCount = new AtomicInteger(0);
            this.resumeTime = new AtomicLong(0L);
        }
    }
}
