package me.xginko.aef.modules.chat.commandwhitelist;

import com.destroystokyo.paper.event.server.AsyncTabCompleteEvent;
import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListener;
import com.github.retrooper.packetevents.event.PacketListenerAbstract;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketReceiveEvent;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientChatCommand;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientChatMessage;
import com.github.retrooper.packetevents.wrapper.play.client.WrapperPlayClientTabComplete;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerTabComplete;
import io.papermc.lib.PaperLib;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.CommandUtil;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.server.TabCompleteEvent;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Credits go to: YouHaveTrouble (https://github.com/YouHaveTrouble/CommandWhitelist)
 */
public class CommandWhitelist extends AEFModule implements PacketListener, Listener {

    private final PacketListenerAbstract abstractListener;
    private Listener commandSendListener;
    private final Set<String> allowedCommands, bannedSubCommands;
    private final boolean usePackets, shouldLog;

    public CommandWhitelist() {
        super("chat.command-whitelist");
        config.addComment(configPath + ".enable",
                "This will make it pretty much impossible to find your plugins as\n" +
                        "only the commands you specify will be able to work.\n" +
                        "Allow bypass using permission: " + AEFPermission.BYPASS_CMD_WHITELIST.string());
        this.shouldLog = config.getBoolean(configPath + ".log", false,
                "Will show logs when a command was denied.");
        this.usePackets = config.getBoolean(configPath + ".use-packets", true,
                "Recommended to use when on 1.12. Otherwise only use if you're having issues.");
        this.allowedCommands = config.getList(configPath + ".whitelisted-commands", Arrays.asList(
                                "help", "vote", "kill", "discord", "togglechat", "toggleconnectionmsgs", "toggletells",
                                "togglewhispering", "toggleprivatemsgs", "ignore", "ignorelist", "ignorehard",
                                "toggledeathmsg", "dmt", "worldstats", "stats", "tps", "msg", "whisper", "w", "m", "t",
                                "pm", "tell", "r", "reply", "last"),
                        "Add all commands you WANT your players to be able to access\n" +
                                "WITHOUT the '/'. Not case sensitive.")
                .stream()
                .map(String::toLowerCase)
                .collect(Collectors.toCollection(HashSet::new));
        bannedSubCommands = new HashSet<>(config.getList(configPath + ".blacklisted-subcommands",
                Arrays.asList("help about", "vote List", "vote Best", "vote Total", "worldstats reload", "stats reload"),
                "Add all subcommands you DON'T want your players to be able\n" +
                        "to access. Case sensitive!"));
        if (CWCommandSendListener.isSupported())
            this.commandSendListener = new CWCommandSendListener(allowedCommands);
        this.abstractListener = asAbstract(PacketListenerPriority.HIGHEST);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        if (commandSendListener != null)
            plugin.getServer().getPluginManager().registerEvents(commandSendListener, plugin);
        if (usePackets) {
            if (AnarchyExploitFixes.config().packets_disabled) {
                warn("Can't enable packet listener because packet events is disabled in config.");
            } else {
                PacketEvents.getAPI().getEventManager().registerListener(abstractListener);
            }
        }
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.config().getBoolean(configPath + ".enable", false);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        if (commandSendListener != null)
            HandlerList.unregisterAll(commandSendListener);
        PacketEvents.getAPI().getEventManager().unregisterListener(abstractListener);
    }

    @Override
    public void onPacketReceive(PacketReceiveEvent event) {
        if (event.isCancelled()) return;
        if (event.getPacketType() == PacketType.Play.Client.TAB_COMPLETE) {
            if (PaperLib.getMinecraftVersion() > 12) return;

            final Player player = (Player) event.getPlayer();
            if (player != null && player.hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.string())) return;

            String text = new WrapperPlayClientTabComplete(event).getText();
            if (!text.startsWith("/")) return; // We only care about the initial command, everything else is handled by the API
            event.setCancelled(true); // The response for this packet will be handled by us, not the server.

            List<WrapperPlayServerTabComplete.CommandMatch> suggestions = new ArrayList<>();

            for (String allowedCommand : allowedCommands) {
                if (text.equals("/")) {
                    suggestions.add(new WrapperPlayServerTabComplete.CommandMatch("/" + allowedCommand, null));
                }
                else if (allowedCommand.startsWith(text.substring(1))) {
                    suggestions.add(new WrapperPlayServerTabComplete.CommandMatch("/" + allowedCommand, null));
                }
            }

            if (suggestions.isEmpty()) {
                return;
            }

            event.getUser().sendPacket(new WrapperPlayServerTabComplete(
                    null,
                    new WrapperPlayServerTabComplete.CommandRange(0, suggestions.size()),
                    suggestions
            ));

            return;
        }

        String message;
        if (event.getPacketType() == PacketType.Play.Client.CHAT_MESSAGE) {
            message = new WrapperPlayClientChatMessage(event).getMessage();
            if (!message.startsWith("/")) return;
        } else if (event.getPacketType() == PacketType.Play.Client.CHAT_COMMAND) {
            message = new WrapperPlayClientChatCommand(event).getCommand();
        } else {
            return;
        }

        final Player player = (Player) event.getPlayer();
        if (player != null && player.hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.string())) return;

        if (!allowedCommands.contains(CommandUtil.getCommandLabel(message).toLowerCase())) {
            event.setCancelled(true);
            if (player != null) player.sendMessage(AnarchyExploitFixes.getLang(player.getLocale()).chat_CommandWhitelist_BadCommand);
            if (shouldLog) info(event.getUser().getName() + " tried to execute a non whitelisted command: " + message);
            return;
        }

        for (String bannedSubCommand : bannedSubCommands) {
            if (message.toLowerCase().substring(1).startsWith(bannedSubCommand)) {
                event.setCancelled(true);
                if (player != null) player.sendMessage(AnarchyExploitFixes.getLang(player.getLocale()).chat_CommandWhitelist_BadCommand);
                if (shouldLog) info(event.getUser().getName() + " tried to execute a blacklisted subcommand: " + message);
                return;
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST)
    private void onCommandPreProcess(PlayerCommandPreprocessEvent event) {
        final Player player = event.getPlayer();
        if (player.hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.string())) return;

        String message = event.getMessage();
        String commandLabel = CommandUtil.getCommandLabel(message).toLowerCase();
        String fullCommand = message.substring(commandLabel.length()+1);
        fullCommand = "/"+commandLabel+fullCommand;
        event.setMessage(fullCommand);

        if (!allowedCommands.contains(commandLabel)) {
            event.setCancelled(true);
            player.sendMessage(AnarchyExploitFixes.getLang(player.getLocale()).chat_CommandWhitelist_BadCommand);
            if (shouldLog) info(player.getName() + " tried to execute a non whitelisted command: " + fullCommand);
            return;
        }

        for (String bannedSubCommand : bannedSubCommands) {
            if (message.toLowerCase().substring(1).startsWith(bannedSubCommand)) {
                event.setCancelled(true);
                player.sendMessage(AnarchyExploitFixes.getLang(player.getLocale()).chat_CommandWhitelist_BadCommand);
                if (shouldLog) info(player.getName() + " tried to execute a blacklisted subcommand: " + message);
                return;
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onAsyncCommandTabComplete(AsyncTabCompleteEvent event) {
        if (event.getCompletions().isEmpty()) return;
        if (!(event.getSender() instanceof Player)) return;
        if (event.getSender().hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.string())) return;

        event.setCompletions(getFilteredTabCompletions(event.getBuffer(), event.getCompletions()));
    }

    @EventHandler(priority = EventPriority.HIGH, ignoreCancelled = true)
    private void onCommandTabComplete(TabCompleteEvent event) {
        if (event.getCompletions().isEmpty()) return;
        if (!(event.getSender() instanceof Player)) return;
        if (event.getSender().hasPermission(AEFPermission.BYPASS_CMD_WHITELIST.string())) return;

        event.setCompletions(getFilteredTabCompletions(event.getBuffer(), event.getCompletions()));
    }

    private List<String> getFilteredTabCompletions(String buffer, List<String> suggestions) {
        if (buffer.startsWith("/")) buffer = buffer.substring(1);
        List<String> suggestionsList = new ArrayList<>(suggestions);
        if (suggestions.isEmpty() || bannedSubCommands.isEmpty()) return suggestionsList;
        for (String bannedSubCommand : bannedSubCommands) {
            String scommand = CommandUtil.cutLastArgument(bannedSubCommand);
            if (buffer.startsWith(scommand)) {
                String slast = CommandUtil.getLastArgument(bannedSubCommand);
                while (suggestionsList.contains(slast))
                    suggestionsList.remove(slast);
            }
        }
        return suggestionsList;
    }
}
