package me.xginko.aef.modules.patches;

import com.cryptomorin.xseries.XMaterial;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.WorldUtil;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerTeleportEvent;

import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class PearlPhase extends AEFModule implements Listener {

    private final Set<Material> glitchyMaterial;
    private final double maxDistance;
    private final int radius;

    public PearlPhase() {
        super("patches.pearl-phase");
        config.addComment(configPath+ ".enable",
                "Attempts to patch a pearl phasing exploit by cancelling the teleport\n" +
                        "if the pearl is thrown at or near a specific block.\n" +
                        "At the time of the creation of this module, this is an issue with NoCheatPlus.");
        this.radius = Math.min(1, config.getInt(configPath + ".search-radius", 2,
                "How many blocks around the teleport location should be searched\n" +
                        "for potential glitch blocks if the teleport location isn't one itself."));
        this.maxDistance = config.getDouble(configPath + ".maximum-distance-to-cancel-teleport", 3.0);
        Stream<Material> concatA = Stream.concat(MaterialUtil.SLAB_LIKE.stream(),
                Stream.of(XMaterial.COBWEB, XMaterial.POWDER_SNOW).filter(XMaterial::isSupported).map(XMaterial::parseMaterial));
        Stream<Material> concatB = Stream.concat(MaterialUtil.PRESSURE_PLATES.stream(), MaterialUtil.TRAPDOORS.stream());
        List<String> defaults = Stream.concat(concatA, concatB)
                .map(Enum::name)
                .sorted()
                .collect(Collectors.toList());
        this.glitchyMaterial = config.getList(configPath+".glitchy-materials", defaults)
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath+".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerTeleport(PlayerTeleportEvent event) {
        if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) return;

        Location destination = event.getTo();
        if (LocationUtil.getRelDistance2D(event.getFrom(), destination) >= maxDistance) return;

        Block destBlock = destination.getBlock();

        if (glitchyMaterial.contains(destBlock.getType())) {
            event.setCancelled(true);
            return;
        }

        int centerX = destBlock.getX();
        int centerY = destBlock.getY();
        int centerZ = destBlock.getZ();
        World world = destBlock.getWorld();

        for (int x = centerX - radius; x <= centerX + radius; x++) {
            for (int z = centerZ - radius; z <= centerZ + radius; z++) {
                for (int y = Math.max(WorldUtil.getMinWorldHeight(world), centerY - radius); y <= centerY + radius; y++) {
                    if (y > world.getMaxHeight()) break;

                    if (glitchyMaterial.contains(world.getBlockAt(x, y, z).getType())) {
                        event.setCancelled(true);
                        return;
                    }
                }
            }
        }
    }
}
