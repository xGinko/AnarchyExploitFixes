package me.xginko.aef.modules.lagpreventions;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.config.Config;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.models.ChunkUID;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockExplodeEvent;
import org.bukkit.event.entity.EntityExplodeEvent;

import java.time.Duration;
import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

public class StashExplosions implements AEFModule, Listener {

    private final Cache<ChunkUID, Integer> containerExplosions;
    private final Set<Material> storageTypes;
    private final int amountAtWhichToTakeAction;
    private final boolean logIsEnabled;

    public StashExplosions() {
        shouldEnable();
        Config config = AnarchyExploitFixes.config();
        config.addComment(configPath() + ".enable",
                "Explodes containers without dropping items after a certain amount\n" +
                        "of exploded containers per chunk.");
        this.logIsEnabled = config.getBoolean(configPath() + ".log", false);
        this.amountAtWhichToTakeAction = config.getInt(configPath() + ".min-explosions-before-drops-disable", 6,
                "How many container blocks in a chunk can be blown up until items no longer drop from them.");
        this.containerExplosions = Caffeine.newBuilder().expireAfterWrite(Duration.ofSeconds(
                Math.max(1, config.getInt(configPath() + ".time-in-seconds", 3,
                        "The time in seconds to wait after an explosion for another one to happen.\n" +
                                "If no explosion happens within x seconds after the first one, the count resets to 0."))
        )).build();
        this.storageTypes = config.getList(configPath() + ".container-types", MaterialUtil.INVENTORY_HOLDER_BLOCKS
                        .stream()
                        .filter(material -> !MaterialUtil.SHULKER_BOXES.contains(material))
                        .map(Enum::name)
                        .collect(Collectors.toList()))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
    }

    @Override
    public String configPath() {
        return "lag-preventions.disable-item-drops-during-large-stash-explosions";
    }

    @Override
    public void enable() {
        AnarchyExploitFixes plugin = AnarchyExploitFixes.getInstance();
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public boolean shouldEnable() {
        return AnarchyExploitFixes.config().getBoolean(configPath() + ".enable", false);
    }

    private void handleExplosion(Chunk chunk, List<Block> affectedBlocks) {
        ChunkUID chunkUID = ChunkUID.of(chunk);
        Integer containerExplosionsInChunk = containerExplosions.getIfPresent(chunkUID);
        if (containerExplosionsInChunk == null) containerExplosionsInChunk = 0;

        if (containerExplosionsInChunk > amountAtWhichToTakeAction) {
            if (logIsEnabled) info(
                    "Not dropping contents of storage block(s) affected by explosion at chunk " +
                    "x:" + chunk.getX() + ", z:" + chunk.getZ() + " because more than " + amountAtWhichToTakeAction +
                    " containers have already exploded within the configured timeframe.");

            affectedBlocks.removeIf(block -> {
                if (storageTypes.contains(block.getType())) {
                    block.setType(Material.AIR);
                    return true;
                }
                return false;
            });

            return;
        }

        for (Block toExplode : affectedBlocks) {
            if (storageTypes.contains(toExplode.getType())) {
                containerExplosionsInChunk++;
            }
        }

        containerExplosions.put(chunkUID, containerExplosionsInChunk);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onBlockExplode(BlockExplodeEvent event) {
        handleExplosion(event.getBlock().getChunk(), event.blockList());
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onEntityExplode(EntityExplodeEvent event) {
        handleExplosion(event.getEntity().getChunk(), event.blockList());
    }
}
