package me.xginko.aef.modules.illegals.items;

import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.papermc.paper.event.player.PrePlayerAttackEntityEvent;
import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.enums.IllegalHandling;
import me.xginko.aef.enums.ItemLegality;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.CachingPermTool;
import me.xginko.aef.utils.EntityUtil;
import me.xginko.aef.utils.MaterialUtil;
import me.xginko.aef.utils.models.ExpiringSet;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.event.Event;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockDispenseEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryInteractEvent;
import org.bukkit.event.inventory.InventoryMoveItemEvent;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.event.player.PlayerAttemptPickupItemEvent;
import org.bukkit.event.player.PlayerDropItemEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;
import org.bukkit.event.player.PlayerItemConsumeEvent;
import org.bukkit.event.world.ChunkLoadEvent;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.checkerframework.checker.nullness.qual.PolyNull;

import java.time.Duration;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

public abstract class IllegalItemModule extends AEFModule implements Listener {

    public abstract ItemLegality legalityOf(ItemStack itemStack);
    public abstract void handleItem(ItemStack itemStack, ItemLegality legality);

    protected final AEFPermission bypassPermission;
    protected final IllegalHandling handling;
    protected final Set<Listener> optionalListeners;
    private final Cache<Class<? extends Event>, ExpiringSet<Object>> listenerCooldowns;
    private final Function<Class<? extends Event>, @PolyNull ExpiringSet<Object>> createIfAbsent;

    public IllegalItemModule(String configPath, AEFPermission bypassPermission) {
        super(configPath);
        this.bypassPermission = bypassPermission;
        this.optionalListeners = new HashSet<>();
        String configuredHandling = config.getString(configPath + ".handling", IllegalHandling.PREVENT_USE_ONLY.name(),
                "Available options:\n" + Arrays.stream(IllegalHandling.values())
                        .map(option -> option.name() + " - " + option.description())
                        .collect(Collectors.joining("\n")));
        IllegalHandling handling;
        try {
            handling = IllegalHandling.valueOf(configuredHandling);
        } catch (IllegalArgumentException e) {
            handling = IllegalHandling.PREVENT_USE_ONLY;
            warn("Handling option '" + configuredHandling + "' not recognized. Defaulting to " + handling.name());
        }
        this.handling = handling;

        final boolean guiPluginsSupported = config.getBoolean(configPath + ".gui-plugins-supported", false, """
                Enable this if you have problems with the plugin removing items from chest guis.""");
        if (this.handling == IllegalHandling.STRICT) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onInventoryOpen(InventoryOpenEvent event) {
                    if (CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) return;
                    // Check if the inventory is connected to a location in the game. If it is not,
                    // it was very likely created by a plugin
                    if (!guiPluginsSupported || event.getInventory().getLocation() != null) {
                        for (ItemStack invItem : event.getInventory()) {
                            handleItem(invItem, legalityOf(invItem));
                        }
                    }
                }
            });
        }

        if (config.getBoolean(configPath + ".prevent-hopper32k-mechanic", false, """
                Prevents Hopper32k mechanic of placing a shulker containing illegals on top\s
                of a hopper, then using the illegal out of the hopper's inventory.\s
                WARNING: Hooks into InventoryMoveItemEvent, which can become VERY resource\s
                intense as the event fires in high frequencies as soon as players start using\s
                farms or item sorters. Recommended to leave off if not necessary.""")) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onItemGoesThroughHopper(InventoryMoveItemEvent event) {
                    if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
                        event.setCancelled(true);
                    }
                }
            });
        }

        final boolean checkOnChunkload = config.getBoolean(configPath + ".check-on-chunkload.enable", false, """
                WARNING: CHECKING ON CHUNKLOAD IS NOT RECOMMENDED AS IT IS VERY RESOURCE INTENSE.\s
                BE VERY SURE YOU ACTUALLY NEED THIS.\s
                Iterates over all blocks in a chunk when it is loaded and checks any inventories\s
                for illegals. If a container with illegals is found, the container will be REMOVED.""");
        final boolean removeContainers = config.getBoolean(configPath + ".check-on-chunkload.remove-container", false, """
                If set to true, immediately replaces the container with air. Otherwise, will try\s
                to handle items separately.""");
        if (checkOnChunkload) {
            optionalListeners.add(new Listener() {
                @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
                private void onChunkLoad(ChunkLoadEvent event) {
                    if (event.isNewChunk()) return;

                    Chunk chunk = event.getChunk();
                    final int minY = event.getWorld().getMinHeight();
                    final int maxY = event.getWorld().getMaxHeight();

                    for (int x = 0; x < 16; x++) {
                        for (int z = 0; z < 16; z++) {
                            for (int y = minY; y < maxY; y++) {
                                Block block = chunk.getBlock(x, y, z);
                                if (!MaterialUtil.INVENTORY_HOLDERS.contains(block.getType())) continue;

                                if (removeContainers) {
                                    if (legalityOf(((InventoryHolder) block.getState()).getInventory()) != ItemLegality.LEGAL)
                                        block.setType(Material.AIR, false);
                                } else {
                                    BlockState blockState = block.getState(false);
                                    for (ItemStack itemStack : ((InventoryHolder) blockState).getInventory())
                                        handleItem(itemStack, legalityOf(itemStack));
                                    blockState.update(true, false);
                                }
                            }
                        }
                    }
                }
            });
        }

        this.listenerCooldowns = Caffeine.newBuilder().expireAfterWrite(Duration.ofMinutes(5)).build();
        final Duration delay = Duration.ofMillis(config.getInt(configPath+".check-rate-limit-millis", 3000, """
                The time in milliseconds to wait before performing another check,\s
                if a check was positive. Helps with lag resulting from repeatedly\s
                checking illegals."""));
        this.createIfAbsent = eventClass -> new ExpiringSet<>(delay);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        optionalListeners.forEach(optional -> plugin.getServer().getPluginManager().registerEvents(optional, plugin));
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        optionalListeners.forEach(HandlerList::unregisterAll);
        optionalListeners.clear();
    }

    public ItemLegality legalityOf(Iterable<ItemStack> itemStacks) {
        if (itemStacks == null) {
            return ItemLegality.LEGAL;
        }

        for (ItemStack itemStack : itemStacks) {
            if (legalityOf(itemStack) != ItemLegality.LEGAL) {
                return ItemLegality.CONTAINS_ILLEGAL;
            }
        }

        return ItemLegality.LEGAL;
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerItemConsume(PlayerItemConsumeEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onBlockDispense(BlockDispenseEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getBlock().getLocation())) {
            event.setCancelled(true);
            return;
        }

        if (legalityOf(event.getItem()) != ItemLegality.LEGAL) {
            event.setCancelled(true);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getBlock().getLocation());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerArmorChange(PlayerArmorChangeEvent event) {
        if (handling == IllegalHandling.PREVENT_USE_ONLY) return; // Cant cancel this event

        if (!CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            handleItem(event.getNewItem(), legalityOf(event.getNewItem()));
            handleItem(event.getOldItem(), legalityOf(event.getOldItem()));
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onInventoryClick(InventoryClickEvent event) {
        if (CachingPermTool.hasPermission(bypassPermission, event.getWhoClicked())) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getWhoClicked().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemLegality clickedLegality = legalityOf(event.getCurrentItem());
        if (clickedLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(event.getCurrentItem(), clickedLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
        }

        ItemLegality cursorLegality = legalityOf(event.getCursor());
        if (cursorLegality != ItemLegality.LEGAL) {
            event.setCancelled(true);
            handleItem(event.getCursor(), cursorLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onInventoryInteract(InventoryInteractEvent event) {
        if (CachingPermTool.hasPermission(bypassPermission, event.getWhoClicked())) return;

        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getWhoClicked().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        for (ItemStack invItem : event.getInventory()) {
            ItemLegality invItemLegality = legalityOf(invItem);
            if (invItemLegality != ItemLegality.LEGAL) {
                event.setCancelled(true);
                handleItem(invItem, invItemLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getWhoClicked().getUniqueId());
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPrePlayerAttackEntity(PrePlayerAttackEntityEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack mainHandItem = event.getPlayer().getInventory().getItemInMainHand();
        final ItemLegality mainHandLegality = legalityOf(mainHandItem);
        if (mainHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(mainHandItem, mainHandLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }

        ItemStack offHandItem = event.getPlayer().getInventory().getItemInOffHand();
        final ItemLegality offHandLegality = legalityOf(offHandItem);
        if (offHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(offHandItem, offHandLegality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onEntityDamageByEntity(EntityDamageByEntityEvent event) {
        if (event.getDamager().getType() == EntityType.PLAYER) {
            final Player player = (Player) event.getDamager();

            if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(player.getUniqueId())) {
                event.setCancelled(true);
                return;
            }

            ItemStack mainHandItem = player.getInventory().getItemInMainHand();
            final ItemLegality mainHandLegality = legalityOf(mainHandItem);
            if (mainHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, player)) {
                event.setCancelled(true);
                handleItem(mainHandItem, mainHandLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(player.getUniqueId());
            }

            ItemStack offHandItem = player.getInventory().getItemInOffHand();
            final ItemLegality offHandLegality = legalityOf(offHandItem);
            if (offHandLegality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, player)) {
                event.setCancelled(true);
                handleItem(offHandItem, offHandLegality);
                listenerCooldowns.get(event.getClass(), createIfAbsent).add(player.getUniqueId());
            }
            return;
        }

        if (EntityUtil.isLivingEntity(event.getDamager())) {
            if (legalityOf(((LivingEntity) event.getDamager()).getActiveItem()) != ItemLegality.LEGAL) {
                event.setCancelled(true);
                if (handling != IllegalHandling.PREVENT_USE_ONLY)
                    event.getDamager().getScheduler().execute(plugin, event.getDamager()::remove, null, 1L);
                return;
            }
        }

        if (EntityUtil.isInventoryHolder(event.getDamager())) {
            if (legalityOf(((InventoryHolder) event.getDamager()).getInventory()) != ItemLegality.LEGAL) {
                event.setCancelled(true);
                if (handling != IllegalHandling.PREVENT_USE_ONLY)
                    event.getDamager().getScheduler().execute(plugin, event.getDamager()::remove, null, 1L);
            }
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerAttemptPickupItem(PlayerAttemptPickupItemEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack pickUpItem = event.getItem().getItemStack();
        final ItemLegality legality = legalityOf(pickUpItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(pickUpItem, legality);
            event.getItem().setItemStack(pickUpItem);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerDropItem(PlayerDropItemEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack droppedItem = event.getItemDrop().getItemStack();
        final ItemLegality legality = legalityOf(droppedItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            handleItem(droppedItem, legality);
            event.getItemDrop().setItemStack(droppedItem);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = false)
    public void onPlayerInteract(PlayerInteractEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack interactItem = event.getItem();
        final ItemLegality legality = legalityOf(interactItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(interactItem, legality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    public void onPlayerInteractEntity(PlayerInteractEntityEvent event) {
        if (listenerCooldowns.get(event.getClass(), createIfAbsent).contains(event.getPlayer().getUniqueId())) {
            event.setCancelled(true);
            return;
        }

        ItemStack handItem = event.getPlayer().getInventory().getItem(event.getHand());
        final ItemLegality legality = legalityOf(handItem);
        if (legality != ItemLegality.LEGAL && !CachingPermTool.hasPermission(bypassPermission, event.getPlayer())) {
            event.setCancelled(true);
            handleItem(handItem, legality);
            listenerCooldowns.get(event.getClass(), createIfAbsent).add(event.getPlayer().getUniqueId());
        }
    }
}
