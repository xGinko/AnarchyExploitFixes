package me.xginko.aef.modules.packets;

import com.cryptomorin.xseries.XMaterial;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.protocol.item.ItemStack;
import com.github.retrooper.packetevents.protocol.item.type.ItemType;
import com.github.retrooper.packetevents.protocol.nbt.NBTCompound;
import com.github.retrooper.packetevents.protocol.nbt.NBTList;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerSetSlot;
import io.github.retrooper.packetevents.util.SpigotConversionUtil;

import java.util.List;

public class BeehiveCoordinates extends PacketModule {

    private final String[] entityDataTagsToRemove;
    private final ItemType beehive, beenest;

    public BeehiveCoordinates() {
        super("patches.remove-beehive-coordinates", PacketListenerPriority.HIGHEST);
        config.addComment(configPath + ".enable", """
                Patches an exploit that allows players to obtain another player's\s
                coordinates by trading them for Beehives or Beenests.\s
                If the traded item contains any bees, the stored bee's NBT data can\s
                then be read from the item.\s
                This data includes, but is not limited to:\s
                - XYZ coordinates of where the bee has its hive\s
                - XYZ of the bee's last coordinates before entering it's hive\s
                - XYZ coordinates of where the bee last visited a flower\s
                - XYZ coordinates of where the bee was first spawned into existence\s
                - UID of the world the bee was first spawned into existence""");
        this.entityDataTagsToRemove = config.getList(configPath + ".tags",
                List.of("Pos", "HivePos", "FlowerPos", "Paper.Origin", "Paper.OriginWorld", "WorldUUIDMost", "WorldUUIDLeast"), """
                        The NBT tags to filter from the item. These are the Keys that hold\s
                        the position data. You may add more tags you want removed here.""")
                .toArray(new String[0]);
        XMaterial xBeeHive = XMaterial.BEEHIVE;
        this.beehive = xBeeHive.isSupported() ? SpigotConversionUtil.fromBukkitItemMaterial(xBeeHive.parseMaterial()) : null;
        XMaterial xBeeNest = XMaterial.BEE_NEST;
        this.beenest = xBeeNest.isSupported() ? SpigotConversionUtil.fromBukkitItemMaterial(xBeeNest.parseMaterial()) : null;
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", true) && beehive != null && beenest != null;
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.isCancelled()) return;
        if (event.getPacketType() != PacketType.Play.Server.SET_SLOT) return;

        WrapperPlayServerSetSlot packet = new WrapperPlayServerSetSlot(event);

        ItemStack itemStack = packet.getItem();
        if (itemStack == null || itemStack.isEmpty()) return;
        if (itemStack.getType() != beenest && itemStack.getType() != beehive) return;

        NBTCompound nbt = itemStack.getNBT();
        if (fixCompound(nbt)) {
            itemStack.setNBT(nbt);
            packet.setItem(itemStack);
            event.markForReEncode(true);
        }
    }

    private boolean fixCompound(NBTCompound compound) {
        if (compound == null || compound.isEmpty()) return false;

        boolean needsReEncode = false;

        if (compound.getTags().containsKey("Bees")) {
            NBTList<NBTCompound> bees = compound.getCompoundListTagOrNull("Bees");
            if (bees == null || bees.isEmpty()) return needsReEncode;

            for (int i = 0; i < bees.size(); i++) {
                NBTCompound beeEntity = bees.getTag(i);
                NBTCompound beeEntityData = beeEntity.getCompoundTagOrNull("EntityData");
                if (beeEntityData != null) {
                    for (String toRemove : entityDataTagsToRemove) {
                        if (beeEntityData.removeTag(toRemove) != null) {
                            needsReEncode = true;
                        }
                    }
                    if (needsReEncode)
                        beeEntity.setTag("EntityData", beeEntityData);
                }
                if (needsReEncode)
                    bees.setTag(i, beeEntity);
            }

            if (needsReEncode)
                compound.setTag("Bees", bees);
        }

        if (compound.getTags().containsKey("Items")) {
            NBTList<NBTCompound> items = compound.getCompoundListTagOrNull("Items");
            if (items == null || items.isEmpty()) return needsReEncode;

            for (int i = 0; i < items.size(); i++) {
                NBTCompound item = items.getTag(i);
                NBTCompound itemRootCompound = item.getCompoundTagOrNull("tag");
                if (fixCompound(itemRootCompound)) {
                    items.setTag(i, item);
                    needsReEncode = true;
                }
            }

            if (needsReEncode)
                compound.setTag("Items", items);
        }

        if (compound.getTags().containsKey("BlockEntityTag")) {
            NBTCompound blockEntityTag = compound.getCompoundTagOrNull("BlockEntityTag");
            if (fixCompound(blockEntityTag)) {
                compound.setTag("BlockEntityTag", blockEntityTag);
                needsReEncode = true;
            }
        }

        return needsReEncode;
    }
}
