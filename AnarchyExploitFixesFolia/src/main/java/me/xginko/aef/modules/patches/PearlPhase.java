package me.xginko.aef.modules.patches;

import com.cryptomorin.xseries.XMaterial;
import me.xginko.aef.AnarchyExploitFixes;
import me.xginko.aef.modules.AEFModule;
import me.xginko.aef.utils.LocationUtil;
import me.xginko.aef.utils.MaterialUtil;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerTeleportEvent;

import java.util.EnumSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class PearlPhase extends AEFModule implements Listener {

    private final Set<Material> glitchyMaterial;
    private final int radius, maximumDistanceToCancel;
    private long schedulingTimeoutMillis;

    public PearlPhase() {
        super("patches.pearl-phase");
        config.addComment(configPath+ ".enable",
                "Attempts to patch a pearl phasing exploit by cancelling the teleport\n" +
                        "if the pearl is thrown at or near a specific block type.");
        this.radius = Math.min(1, config.getInt(configPath + ".search-radius", 2,
                "How many blocks around the teleport location should be searched\n" +
                        "for potential glitch blocks if the teleport location isn't one itself."));
        this.maximumDistanceToCancel = config.getInt(configPath + ".maximum-distance-to-cancel-teleport", 3);

        Stream<Material> concatA = Stream.concat(MaterialUtil.SLAB_LIKE.stream(),
                Stream.of(XMaterial.COBWEB, XMaterial.POWDER_SNOW).filter(XMaterial::isSupported).map(XMaterial::parseMaterial));
        Stream<Material> concatB = Stream.concat(MaterialUtil.PRESSURE_PLATES.stream(), MaterialUtil.TRAPDOORS.stream());
        List<String> defaults = Stream.concat(concatA, concatB)
                .map(Enum::name)
                .sorted()
                .toList();
        this.glitchyMaterial = config.getList(configPath+".glitchy-materials", defaults)
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
        if (AnarchyExploitFixes.isServerFolia()) {
            this.schedulingTimeoutMillis = config.getInt(configPath + ".check-timeout-millis", 800,
                    "We will have to schedule the check on folia, meaning theres a chance\n" +
                            "the task might take longer than expected. To make sure that does not cause\n" +
                            "more lag, we set a time limit here.");
        }
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath+".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerTeleport(PlayerTeleportEvent event) {
        if (event.getCause() != PlayerTeleportEvent.TeleportCause.ENDER_PEARL) return;

        Location destination = event.getTo();
        if (LocationUtil.getRelDistance2D(event.getFrom(), destination) >= maximumDistanceToCancel) return;

            if (!AnarchyExploitFixes.isServerFolia()) {
            if (isPotentialPhase(destination))
                event.setCancelled(true);
            return;
        }

        try {
            CompletableFuture<Boolean> future = new CompletableFuture<>();
            // We will have to schedule the check on folia because the event might not
            // fire from the same thread as the region of the destination location.
            plugin.getServer().getRegionScheduler().execute(plugin, destination, () ->
                    future.complete(isPotentialPhase(destination)));
            if (future.get(schedulingTimeoutMillis, TimeUnit.MILLISECONDS))
                event.setCancelled(true);
        } catch (ExecutionException | InterruptedException | TimeoutException e) {
            error("Error while checking if the destination would trigger phasing.", e);
        }
    }

    private boolean isPotentialPhase(Location location) {
        Block destBlock = location.getBlock();

        if (glitchyMaterial.contains(destBlock.getType())) {
            return true;
        }

        int centerX = destBlock.getX();
        int centerY = destBlock.getY();
        int centerZ = destBlock.getZ();
        World world = destBlock.getWorld();

        for (int x = centerX - radius; x <= centerX + radius; x++) {
            for (int z = centerZ - radius; z <= centerZ + radius; z++) {
                for (int y = Math.max(world.getMinHeight(), centerY - radius); y <= centerY + radius; y++) {
                    if (y > world.getMaxHeight()) break;

                    if (glitchyMaterial.contains(world.getBlockAt(x, y, z).getType())) {
                        return true;
                    }
                }
            }
        }

        return false;
    }
}
