package me.xginko.aef.modules.illegals.items.enchantments;

import me.xginko.aef.enums.AEFPermission;
import me.xginko.aef.enums.IllegalHandling;
import me.xginko.aef.enums.ItemLegality;
import me.xginko.aef.modules.illegals.items.IllegalItemModule;
import me.xginko.aef.utils.ItemUtil;
import org.bukkit.Material;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.inventory.ItemStack;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import static com.cryptomorin.xseries.XEnchantment.BANE_OF_ARTHROPODS;
import static com.cryptomorin.xseries.XEnchantment.BINDING_CURSE;
import static com.cryptomorin.xseries.XEnchantment.BLAST_PROTECTION;
import static com.cryptomorin.xseries.XEnchantment.CHANNELING;
import static com.cryptomorin.xseries.XEnchantment.DEPTH_STRIDER;
import static com.cryptomorin.xseries.XEnchantment.FIRE_PROTECTION;
import static com.cryptomorin.xseries.XEnchantment.FORTUNE;
import static com.cryptomorin.xseries.XEnchantment.FROST_WALKER;
import static com.cryptomorin.xseries.XEnchantment.INFINITY;
import static com.cryptomorin.xseries.XEnchantment.LOYALTY;
import static com.cryptomorin.xseries.XEnchantment.MENDING;
import static com.cryptomorin.xseries.XEnchantment.MULTISHOT;
import static com.cryptomorin.xseries.XEnchantment.PIERCING;
import static com.cryptomorin.xseries.XEnchantment.PROJECTILE_PROTECTION;
import static com.cryptomorin.xseries.XEnchantment.PROTECTION;
import static com.cryptomorin.xseries.XEnchantment.RIPTIDE;
import static com.cryptomorin.xseries.XEnchantment.SHARPNESS;
import static com.cryptomorin.xseries.XEnchantment.SILK_TOUCH;
import static com.cryptomorin.xseries.XEnchantment.SMITE;
import static com.cryptomorin.xseries.XEnchantment.VANISHING_CURSE;

public class IncompatibleEnchants extends IllegalItemModule {

    private final Set<Material> whitelistedTypes;
    private final Enchantment[] damageEnchants, protectionEnchants;
    private final boolean useWhitelist, blacklistMode, checkStored;

    public IncompatibleEnchants() {
        super("illegals.enchantments.incompatible-enchants", AEFPermission.BYPASS_ILLEGAL_ENCHANT_INCOMPATIBLE);
        this.damageEnchants = new Enchantment[]{SHARPNESS.getEnchant(), SMITE.getEnchant(), BANE_OF_ARTHROPODS.getEnchant()};
        this.protectionEnchants = new Enchantment[]{PROTECTION.getEnchant(), BLAST_PROTECTION.getEnchant(),
                FIRE_PROTECTION.getEnchant(), PROJECTILE_PROTECTION.getEnchant()};
        config.addComment(configPath + ".enable",
                "Bypass permission: " + bypassPermission.string() + "\n" +
                        "Reverts or prevents usage of ItemStacks with Enchantments that\n" +
                        "cannot coexist in vanilla survival minecraft.\n" +
                        "Examples: A bow with mending and infinity or armor with every\n" +
                        "protection enchantment.");
        this.checkStored = config.getBoolean(configPath + ".check-stored-items", false);
        this.useWhitelist = config.getBoolean(configPath + ".item-whitelist-enabled", true);
        this.blacklistMode = config.getBoolean(configPath + ".use-as-blacklist-instead", false);
        this.whitelistedTypes = config.getList(configPath + ".whitelisted-items", Collections.singletonList("BOW"))
                .stream()
                .map(configuredType -> {
                    try {
                        return Material.valueOf(configuredType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(Material.class, configuredType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public ItemLegality legalityOf(ItemStack itemStack) {
        if (itemStack == null || itemStack.getType() == Material.AIR) {
            return ItemLegality.LEGAL;
        }

        if (!useWhitelist || blacklistMode == whitelistedTypes.contains(itemStack.getType())) {
            final Set<Enchantment> enchantments = itemStack.getEnchantments().keySet();

            if (!enchantments.isEmpty()) {
                if (enchantments.contains(SILK_TOUCH.getEnchant()) && enchantments.contains(FORTUNE.getEnchant()))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(DEPTH_STRIDER.getEnchant()) && enchantments.contains(FROST_WALKER.getEnchant()))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(INFINITY.getEnchant()) && enchantments.contains(MENDING.getEnchant()))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(BINDING_CURSE.getEnchant()) && enchantments.contains(VANISHING_CURSE.getEnchant()))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(RIPTIDE.getEnchant())
                        && (enchantments.contains(LOYALTY.getEnchant()) || enchantments.contains(CHANNELING.getEnchant())))
                    return ItemLegality.ILLEGAL;
                if (enchantments.contains(MULTISHOT.getEnchant()) && enchantments.contains(PIERCING.getEnchant()))
                    return ItemLegality.ILLEGAL;

                int dmgEnchCount = 0;
                for (Enchantment damageEnchant : damageEnchants) {
                    if (enchantments.contains(damageEnchant)) {
                        dmgEnchCount++;
                        if (dmgEnchCount > 1) {
                            return ItemLegality.ILLEGAL;
                        }
                    }
                }

                int protEnchCount = 0;
                for (Enchantment protectEnchant : protectionEnchants) {
                    if (enchantments.contains(protectEnchant)) {
                        protEnchCount++;
                        if (protEnchCount > 1) {
                            return ItemLegality.ILLEGAL;
                        }
                    }
                }
            }
        }

        if (checkStored) {
            return legalityOf(ItemUtil.getStoredItems(itemStack));
        }

        return ItemLegality.LEGAL;
    }

    @Override
    public void handleItem(ItemStack itemStack, ItemLegality legality) {
        if (legality == ItemLegality.LEGAL) return;
        if (handling == IllegalHandling.PREVENT_USE_ONLY) return; // We are cancelling the action in the super class

        if (legality == ItemLegality.CONTAINS_ILLEGAL) {
            itemStack.setAmount(0);
            return;
        }

        final Set<Enchantment> enchantments = itemStack.getEnchantments().keySet();

        if (enchantments.contains(SILK_TOUCH.getEnchant()) && enchantments.contains(FORTUNE.getEnchant()))
            itemStack.removeEnchantment(FORTUNE.getEnchant());
        if (enchantments.contains(DEPTH_STRIDER.getEnchant()) && enchantments.contains(FROST_WALKER.getEnchant()))
            itemStack.removeEnchantment(FROST_WALKER.getEnchant());
        if (enchantments.contains(INFINITY.getEnchant()) && enchantments.contains(MENDING.getEnchant()))
            itemStack.removeEnchantment(INFINITY.getEnchant());
        if (enchantments.contains(BINDING_CURSE.getEnchant()) && enchantments.contains(VANISHING_CURSE.getEnchant()))
            itemStack.removeEnchantment(BINDING_CURSE.getEnchant());
        if (enchantments.contains(MULTISHOT.getEnchant()) && enchantments.contains(PIERCING.getEnchant()))
            itemStack.removeEnchantment(MULTISHOT.getEnchant());
        if (enchantments.contains(RIPTIDE.getEnchant()) && (enchantments.contains(LOYALTY.getEnchant()) || enchantments.contains(CHANNELING.getEnchant())))
            itemStack.removeEnchantment(RIPTIDE.getEnchant());

        if (enchantments.contains(SHARPNESS.getEnchant())) { // Prefer keeping sharpness enchantment if present
            for (Enchantment dmgEnchant : damageEnchants) {
                if (dmgEnchant != SHARPNESS.getEnchant()) {
                    itemStack.removeEnchantment(dmgEnchant);
                }
            }
        } else if (enchantments.contains(BANE_OF_ARTHROPODS.getEnchant()) && enchantments.contains(SMITE.getEnchant())) {
            itemStack.removeEnchantment(BANE_OF_ARTHROPODS.getEnchant());
        }

        if (enchantments.contains(PROTECTION.getEnchant())) { // Prefer keeping protection enchantment if present
            for (Enchantment protEnchant : protectionEnchants) {
                if (protEnchant != PROTECTION.getEnchant()) {
                    itemStack.removeEnchantment(protEnchant);
                }
            }
        } else if (enchantments.contains(BLAST_PROTECTION.getEnchant())) { // If protection isn't present, prefer blast protection
            for (Enchantment protEnchant : protectionEnchants) {
                if (protEnchant != BLAST_PROTECTION.getEnchant()) {
                    itemStack.removeEnchantment(protEnchant);
                }
            }
        } else if (enchantments.contains(PROJECTILE_PROTECTION.getEnchant()) && enchantments.contains(FIRE_PROTECTION.getEnchant())) {
            itemStack.removeEnchantment(FIRE_PROTECTION.getEnchant()); // If protection and blast protection is not present, prefer projectile protection
        }
    }
}