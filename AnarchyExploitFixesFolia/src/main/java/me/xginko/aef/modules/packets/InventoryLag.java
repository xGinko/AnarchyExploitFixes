package me.xginko.aef.modules.packets;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.retrooper.packetevents.PacketEvents;
import com.github.retrooper.packetevents.event.PacketListenerPriority;
import com.github.retrooper.packetevents.event.PacketSendEvent;
import com.github.retrooper.packetevents.netty.buffer.ByteBufHelper;
import com.github.retrooper.packetevents.protocol.packettype.PacketType;
import com.github.retrooper.packetevents.protocol.packettype.PacketTypeCommon;
import me.xginko.aef.utils.EntityUtil;
import me.xginko.aef.utils.MaterialUtil;
import org.bukkit.entity.HumanEntity;
import org.bukkit.entity.Player;
import org.bukkit.event.Cancellable;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.Action;
import org.bukkit.event.inventory.InventoryOpenEvent;
import org.bukkit.event.player.PlayerInteractEntityEvent;
import org.bukkit.event.player.PlayerInteractEvent;

import java.time.Duration;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

public class InventoryLag extends PacketModule implements Listener {

    private final Cache<UUID, PlayerData> playerDataCache;
    private final Set<PacketTypeCommon> measuredPacketTypes;
    private final long rateLimitBytes, lockoutBytes, lockoutMillis;
    private final int screenOpenLimit, screenOpenDelay;
    private final boolean closeInventory, log;

    public InventoryLag() {
        super("patches.inventory-lag", PacketListenerPriority.HIGHEST);
        config.addComment(configPath + ".enable", """
                Checks if a player is requesting unusual amounts of traffic from the server\s
                using ItemStacks.\s
                If a player exceeds the limit, they will be put on a cooldown, during which\s
                they will be very limited in terms of ItemStack or Inventory interactions.""");
        this.log = config.getBoolean(configPath + ".log", false, """
                For debug purposes. Don't leave enabled for too long as it is very spammy.""");
        this.closeInventory = config.getBoolean(configPath + ".close-open-inventory", true, """
                Whether to immediately close any open inventory of the player on limit exceed\s
                Note: Closing has to be scheduled so it will take a bit if the server is heavily\s
                lagging.""");
        this.playerDataCache = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(Math.max(1L,
                config.getLong(configPath + ".byte-data-keep-time-millis", 30_000, """
                    The time in millis in which to check if the player exceeded the limit.\s
                    Needs to be at least as long as your lockout duration millis.""")))).build();
        this.rateLimitBytes = config.getLong(configPath + ".rate-limit.bytesize-limit", 8_000_000, """
                The limit in bytes the server has sent the server in the form of ItemStacks,\s
                before the player will be put on a rate-limit.\s
                Should always be lower than your lockout bytesize limit.""");
        this.screenOpenDelay = config.getInt(configPath + ".rate-limit.timeframe-millis", 2500, """
                The time in millis in which a player is allowed to open x amounts of windows\s
                but not more.""");
        this.screenOpenLimit = config.getInt(configPath + ".rate-limit.max-window-opens-per-timeframe", 2, """
                The amount of windows that can be opened during the timeframe-millis.""");
        this.lockoutBytes = config.getLong(configPath + ".lockout.bytesize-limit", 24_000_000, """
                The upper limit in bytes a player is allowed to request from the server\s
                within the configured timeframe before he will be put on cooldown.\s
                During the cooldown, he will not be able to open any inventory screens\s
                or interact with items.""");
        this.lockoutMillis = config.getLong(configPath + ".lockout.duration-millis", 15_000, """
                The time in milliseconds the player will have to wait before\s
                being able to open an inventory again after he exceeded the limit.""");
        this.measuredPacketTypes = config.getList(configPath + ".check-packets", List.of("SET_SLOT", "WINDOW_ITEMS"))
                .stream()
                .map(configuredPacketType -> {
                    try {
                        return PacketType.Play.Server.valueOf(configuredPacketType);
                    } catch (IllegalArgumentException e) {
                        notRecognized(PacketType.Play.Server.class, configuredPacketType);
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .collect(Collectors.toCollection(HashSet::new));
    }

    @Override
    public boolean shouldEnable() {
        return config.getBoolean(configPath + ".enable", false);
    }

    @Override
    public void enable() {
        plugin.getServer().getPluginManager().registerEvents(this, plugin);
        PacketEvents.getAPI().getEventManager().registerListener(asAbstract);
    }

    @Override
    public void disable() {
        HandlerList.unregisterAll(this);
        PacketEvents.getAPI().getEventManager().unregisterListener(asAbstract);
    }

    @Override
    public void onPacketSend(PacketSendEvent event) {
        if (event.isCancelled() || !measuredPacketTypes.contains(event.getPacketType())) return;

        PlayerData data = playerDataCache.get(event.getUser().getUUID(), PlayerData::new);

        long servedBytes = data.servedSetSlotBytes.addAndGet(ByteBufHelper.readableBytes(event.getByteBuf()));
        if (log) info("Player '" + event.getUser().getName() + "' requested " + servedBytes + " bytes in ItemStacks. " +
                "(PacketType: " + event.getPacketType() + ")");

        if (servedBytes <= lockoutBytes) {
            return;
        }

        if (data.cooldownResumeTime.get() > System.currentTimeMillis()) {
            event.setCancelled(true);
            return;
        }

        data.cooldownResumeTime.set(System.currentTimeMillis() + lockoutMillis);

        if (log) warn("Player '" + event.getUser().getName() + "' is now on LOCKOUT as they exceeded" +
                " the set limit (now " + servedBytes + " bytes).");

        if (closeInventory && event.getPlayer() != null) {
            Player player = (Player) event.getPlayer();
            player.getScheduler().execute(plugin, player::closeInventory, null, 1L);
        }
    }

    private void onInventoryOpen(Cancellable event, HumanEntity player) {
        PlayerData data = playerDataCache.get(player.getUniqueId(), PlayerData::new);

        if (data.cooldownResumeTime.get() > System.currentTimeMillis()) {
            event.setCancelled(true);
            if (log) info("Player '" + player.getName() + "' could not open screen because they are on cooldown.");
            return;
        }

        long servedBytes = data.servedSetSlotBytes.get();

        if (
                servedBytes > rateLimitBytes && servedBytes < lockoutBytes
                && data.screenOpenCount.getAndIncrement() > screenOpenLimit
        ) {
            event.setCancelled(true);
            data.cooldownResumeTime.set(System.currentTimeMillis() + screenOpenDelay);
            data.screenOpenCount.set(0);
            if (log) warn("Player '" + player.getName() + "' is now on RATE-LIMIT as they exceeded" +
                    " the set limit (now " + servedBytes + " bytes).");
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerInteract(PlayerInteractEvent event) {
        if (event.getAction() != Action.RIGHT_CLICK_BLOCK) return;

        if (MaterialUtil.INVENTORY_HOLDERS.contains(event.getClickedBlock().getType())) {
            onInventoryOpen(event, event.getPlayer());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onPlayerInteract(PlayerInteractEntityEvent event) {
        if (EntityUtil.isInventoryHolder(event.getRightClicked())) {
            onInventoryOpen(event, event.getPlayer());
        }
    }

    @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)
    private void onInventoryOpen(InventoryOpenEvent event) {
        onInventoryOpen(event, event.getPlayer());
    }

    private static class PlayerData {

        public final UUID uuid;
        public final AtomicLong servedSetSlotBytes, cooldownResumeTime;
        public final AtomicInteger screenOpenCount;

        public PlayerData(UUID uuid) {
            this.uuid = uuid;
            this.servedSetSlotBytes = new AtomicLong(0L);
            this.cooldownResumeTime = new AtomicLong(0L);
            this.screenOpenCount = new AtomicInteger(0);
        }
    }
}