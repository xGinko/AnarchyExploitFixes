package me.moomoo.anarchyexploitfixes.utils.models;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.google.common.util.concurrent.AtomicDouble;
import io.papermc.paper.threadedregions.RegionizedServer;
import io.papermc.paper.threadedregions.ThreadedRegionizer;
import io.papermc.paper.threadedregions.TickRegionScheduler;
import io.papermc.paper.threadedregions.TickRegions;
import me.moomoo.anarchyexploitfixes.AnarchyExploitFixes;
import org.bukkit.Location;
import org.bukkit.Server;
import org.bukkit.World;
import org.bukkit.plugin.java.JavaPlugin;
import org.jetbrains.annotations.NotNull;

import java.time.Duration;

public interface TPSCache {

    double getGlobalTPS();
    double getTPS(Location location);
    double getTPS(World world, int chunkX, int chunkZ);

    static @NotNull TPSCache create(long checkDelayMillis) {
        if (AnarchyExploitFixes.isServerFolia()) {
            return new Folia(AnarchyExploitFixes.getInstance(), checkDelayMillis);
        } else {
            return new Default(AnarchyExploitFixes.getInstance(), checkDelayMillis);
        }
    }

    final class Default implements TPSCache {

        private final Server server;
        private final Cache<Object, Double> cached_tps;
        private static final Object TPS_KEY = new Object(); // Dummy value to associate with tps in the backing Cache

        Default(JavaPlugin plugin, long checkDelayMillis) {
            this.server = plugin.getServer();
            this.cached_tps = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(checkDelayMillis)).build();
        }

        @Override
        public double getGlobalTPS() {
            Double tps = this.cached_tps.getIfPresent(TPS_KEY);
            if (tps == null) {
                tps = this.server.getTPS()[0];
                this.cached_tps.put(TPS_KEY, tps);
            }
            return tps;
        }

        @Override
        public double getTPS(World world, int chunkX, int chunkZ) {
            return getGlobalTPS();
        }

        @Override
        public double getTPS(Location location) {
            return getGlobalTPS();
        }
    }

    final class Folia implements TPSCache {

        private final JavaPlugin plugin;
        private final Server server;
        private final Cache<TickRegionScheduler.RegionScheduleHandle, Double> cached_tps;

        Folia(JavaPlugin plugin, long checkDelayMillis) {
            this.plugin = plugin;
            this.server = plugin.getServer();
            this.cached_tps = Caffeine.newBuilder().expireAfterWrite(Duration.ofMillis(checkDelayMillis)).build();
        }

        @Override
        public double getGlobalTPS() {
            // Get region handle and check if there is already a cached tps for it
            final TickRegionScheduler.RegionScheduleHandle
                    regionHandle = RegionizedServer.getGlobalTickData();
            Double tps = this.cached_tps.getIfPresent(regionHandle);
            if (tps == null) {
                // If nothing is cached yet, get tps and add to cache
                tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
                this.cached_tps.put(regionHandle, tps);
            }
            return tps;
        }

        @Override
        public double getTPS(Location location) {
            if (location == null) return getGlobalTPS();
            return getTPS(location.getWorld(), location.getBlockX() >> 4, location.getBlockZ() >> 4);
        }

        @Override
        public double getTPS(World world, int chunkX, int chunkZ) {
            if (world == null) return getGlobalTPS();
            // Use AtomicDouble because we need a value from the lambda
            // Init with 20 (perfect) tps, so we have a valid and safe fallback value
            AtomicDouble atomic_tps = new AtomicDouble(20.0);
            // Update atomic double via region scheduler execute method so usage of TickRegionScheduler.getCurrentRegion()
            // happens faster and on the thread of the region that owns the location.
            this.server.getRegionScheduler().execute(this.plugin, world, chunkX, chunkZ, () -> {
                // Get the potential separate region that owns the location
                final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                        currentRegion = TickRegionScheduler.getCurrentRegion();
                // If not happening on a separate region, it must mean we're on the main region
                if (currentRegion == null) {
                    atomic_tps.set(getGlobalTPS());
                    return;
                }
                // Get region handle and check if there is already a cached tps for it
                final TickRegionScheduler.RegionScheduleHandle
                        regionHandle = currentRegion.getData().getRegionSchedulingHandle();
                Double tps = this.cached_tps.getIfPresent(regionHandle);
                if (tps == null) {
                    // If nothing is cached yet, get tps and add to cache
                    tps = regionHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average();
                    this.cached_tps.put(regionHandle, tps);
                }
                atomic_tps.set(tps);
            });
            return atomic_tps.get();
        }
    }
}