package me.moomoo.anarchyexploitfixes.prevention;

import me.moomoo.anarchyexploitfixes.Main;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.entity.Vehicle;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockPhysicsEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityPortalEvent;
import org.bukkit.event.entity.ExpBottleEvent;
import org.bukkit.event.entity.ProjectileLaunchEvent;
import org.bukkit.event.vehicle.VehicleCreateEvent;

import java.awt.*;
import java.util.HashSet;
import java.util.Set;

public class LagExploits implements Listener {
    private final Main plugin;
    private final Set<String> throwCoolDown = new HashSet<>();
    private final Set<Location> throwCoolDownLocations = new HashSet<>();

    public LagExploits(Main plugin) {
        this.plugin = plugin;
    }

    @EventHandler
    private void onEntityChange(BlockPhysicsEvent evt) {
        FileConfiguration config = plugin.getConfig();

        double tpsDouble = Bukkit.getServer().getTPS()[0];
        if (evt.getChangedType().hasGravity()) {
            if (tpsDouble < config.getDouble("FallingBlocks")) {
                evt.setCancelled(true);
            } else {
                if (plugin.getConfig().getBoolean("LimitFallingBlocks")) {
                    if (count(evt.getBlock().getChunk().getEntities(), EntityType.FALLING_BLOCK) > config.getInt("FallingBlockLimit")) {
                        evt.setCancelled(true);
                    }
                }
            }
        }
    }

    @EventHandler
    private void onCreate(VehicleCreateEvent evt) {
        if (plugin.getConfig().getBoolean("PreventMinecartLag")) {
            if (countVehicles(evt.getVehicle().getChunk().getEntities()) > plugin.getConfig().getInt("MaxVehiclesInChunk")) {
                evt.setCancelled(true);
            }
        }
    }

    @EventHandler
    private void onPlace(BlockPlaceEvent evt) {
        FileConfiguration config = plugin.getConfig();

        if (evt.getBlockPlaced().getType().hasGravity()) {
            if (plugin.getConfig().getBoolean("LimitFallingBlocks")) {
                if (count(evt.getBlock().getChunk().getEntities(), EntityType.FALLING_BLOCK) > config.getInt("FallingBlockLimit")) {
                    evt.setCancelled(true);
                }
            }
        }
    }

    @EventHandler
    private void onExpBottle(ExpBottleEvent evt) {
        FileConfiguration config = plugin.getConfig();
        if (plugin.getConfig().getBoolean("LimitExpBottles")) {
            if (count(evt.getEntity().getChunk().getEntities(), EntityType.THROWN_EXP_BOTTLE) > config.getInt("ExpBottleLimit")) {
                remove(evt.getEntity().getChunk().getEntities(), EntityType.THROWN_EXP_BOTTLE);
            }
        }
    }

    @EventHandler
    private void onPortal(EntityPortalEvent evt) {
        if (plugin.getConfig().getBoolean("PreventProjectilesFromGoingThroughPortals")) {
            if (evt.getEntityType().isSpawnable() && !evt.getEntityType().isAlive()) {
                evt.setCancelled(true);
            }
        }
    }

    @EventHandler
    private void onThrow(ProjectileLaunchEvent evt) {
        if (plugin.getConfig().getBoolean("PreventSnowBallExploit")) {
            boolean found = false;
            for (Player p : Bukkit.getOnlinePlayers()) {
                Point p1 = new Point(evt.getEntity().getLocation().getBlockX(), evt.getEntity().getLocation().getBlockZ());
                Point p2 = new Point(p.getLocation().getBlockX(), p.getLocation().getBlockZ());
                if (p1.distance(p2) <= 1) {
                    found = true;
                    if (throwCoolDown.contains(p.getName())) {
                        if (evt.getEntity().getType() != EntityType.THROWN_EXP_BOTTLE) {
                            evt.setCancelled(true);
                        }
                    } else {
                        throwCoolDown.add(p.getName());
                        Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> throwCoolDown.remove(p.getName()), 6L);
                    }
                }
            }
            if (!found) {
                boolean done = false;
                for (Location l : throwCoolDownLocations) {
                    Point p1 = new Point(evt.getEntity().getLocation().getBlockX(), evt.getEntity().getLocation().getBlockZ());
                    Point p2 = new Point(l.getBlockX(), l.getBlockZ());
                    // We check if the entity is anywhere near our last
                    if (p1.distance(p2) <= 100) {
                        done = true;
                        evt.setCancelled(true);
                    }
                }
                if (!done) {
                    Location location = evt.getEntity().getLocation();
                    throwCoolDownLocations.add(location);
                    Bukkit.getServer().getScheduler().runTaskLater(plugin, () -> throwCoolDownLocations.remove(location), 20L);
                }
            }
        }
    }

    // Attempt to prevent dropping a shit ton of items.
//    @EventHandler
//    private void onSpawn(ItemSpawnEvent evt){
//        plugin.getLogger().info("item spawn");
//        if(evt.getEntity().getChunk().getEntities().length > 25){
//            evt.setCancelled(true);
//        }
//    }
    private Integer count(Entity[] e, EntityType type) {
        Integer count = 0;
        for (Entity entity : e) {
            if (entity.getType().equals(type)) {
                count++;
            }
        }
        return count;
    }

    private Integer countVehicles(Entity[] e) {
        Integer count = 0;
        for (Entity entity : e) {
            if (entity instanceof Vehicle) {
                count++;
            }
        }
        return count;
    }

    private void remove(Entity[] e, EntityType type) {
        for (Entity entity : e) {
            if (entity.getType().equals(type)) {
                entity.remove();
            }
        }
    }
}
