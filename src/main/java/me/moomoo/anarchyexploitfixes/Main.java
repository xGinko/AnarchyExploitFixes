package me.moomoo.anarchyexploitfixes;

import me.moomoo.anarchyexploitfixes.misc.*;
import me.moomoo.anarchyexploitfixes.patches.*;
import me.moomoo.anarchyexploitfixes.prevention.*;
import org.bstats.bukkit.Metrics;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.ShulkerBox;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.*;
import org.bukkit.event.Listener;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.SkullMeta;
import org.bukkit.inventory.meta.SpawnEggMeta;
import org.bukkit.plugin.PluginManager;
import org.bukkit.plugin.java.JavaPlugin;

import java.awt.*;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

public class Main extends JavaPlugin implements Listener {
    public static final Integer[] oldTotal = {0};
    public static final Integer[] newTotal = {0};
    public final Map<Player, Integer> newChunks = new HashMap<>();
    public final Map<Player, Integer> oldChunks = new HashMap<>();
    public final Set<String> playersInNewChunks = new HashSet<>();
    public final Set<String> connectionMsgs = new HashSet<>();
    public double tps = 20.0;
    public PluginManager pluginManager;

    public void replaceEnchantment(ItemStack item, Enchantment enchantment, Integer level) {
        item.removeEnchantment(enchantment);

        if (enchantment.canEnchantItem(item)) {
            item.addEnchantment(enchantment, level);
        } else {
            if (!getConfig().getBoolean("RevertUnEnchantable"))
                item.addUnsafeEnchantment(enchantment, level);
        }
    }

    @Override
    public void onEnable() {
        Logger log = getLogger();
        pluginManager = getServer().getPluginManager();
        log.info("Registering events");
        // please make a pull request if there is a better way to do this
        register(
                new DupeFixes(this), new DisableWithers(this),
                new Elytra(this), new EndPortalPatch(this),
                new Bedrock(this), new Chat(this),
                new ChunkBan(this), new CommandPreProcess(this),
                new CrashExploits(this), new Illegals(this),
                new JoinMessages(this), new Kicks(this),
                new LagExploits(this), new MyServer(this),
                new NetherRoof(this), new Redstone(this),
                new NetherPortals(this), new GodMode(this),
                new RenderDistance(this), new CoordExploits(this),
                new CommandExploits(this), new WitherSpawning(this),
                new Burrow(this), new BookBan(this),
                new AntiBedTrap(this), new Commands(this),
                new BowBomb(this), new InvalidNames(this)
        );

        if (getConfig().getBoolean("DisableAllProtocolLib")) {
            getLogger().info("You specified to disable all ProtocolLib patches.");
        } else {
            if (getServer().getPluginManager().getPlugin("ProtocolLib") != null) {
                getLogger().info("Detected ProtocolLib!");
                ProtocolLib.protocolLibWrapper(this);
            } else {
                getLogger().warning("Did not detect ProtocolLib, disabling packet patches");
                Bukkit.getScheduler().runTaskTimer(this, () -> getLogger().warning("ProtocolLib plugin not detected, many gamebreaking exploits will not be patched. Download at https://www.spigotmc.org/resources/protocollib.1997/"), 200L, 1200L);
            }
        }

        log.info("Registering events finished");
        log.info("Registering commands");
        getCommand("aef").setExecutor(new Commands(this));
        getCommand("toggleconnectionmsgs").setExecutor(new Commands(this));
        if (getConfig().getBoolean("StrictIllegalPrevention")) {
            Bukkit.getServer().getScheduler().runTaskTimer(this, () -> Bukkit.getWorlds().forEach(b -> b.getPlayers().forEach(e -> e.getInventory().forEach(this::revert))), 0L, 20L);
        }

        if (getConfig().getBoolean("RemoveAllWitherSkulls")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Entity e : w.getEntities()) {
                        if (e.getType() == EntityType.WITHER_SKULL) {
                            e.remove();
                        }
                    }
                }
            }, 0L, 20L);
        }

        ScheduledExecutorService schedulerTPS = Executors.newScheduledThreadPool(1);
        schedulerTPS.scheduleAtFixedRate(() -> {
            Thread t = new Thread(() -> {
                // Try to prevent lag from checking tps in physics event
                tps = Bukkit.getServer().getTPS()[0];
            });
            t.start();
        }, 1, 1, TimeUnit.SECONDS);

        if (getConfig().getBoolean("PreventTooManyEntitiesInChunk")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (ItemUtil.isEntity(entity) && !(entity instanceof LivingEntity)) {
                                if (count > getConfig().getInt("MaxEntitiesInChunk")) {
                                    entity.remove();
                                    if (getConfig().getBoolean("LogEntityRemovals")) {
                                        getLogger().warning("Removed entity " + entity.getType() + " at " + entity.getLocation() + " because reached entity limit of " + getConfig().getInt("MaxEntitiesInChunk"));
                                    }
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, getConfig().getInt("EntityCheckTimeTicks"));
        }

        if (getConfig().getBoolean("StrictVehicleCheck")) {
            Bukkit.getScheduler().runTaskTimer(this, () -> {
                for (World w : Bukkit.getWorlds()) {
                    for (Chunk c : w.getLoadedChunks()) {
                        int count = 0;
                        for (Entity entity : c.getEntities()) {
                            if (entity instanceof Vehicle) {
                                if (count > getConfig().getInt("MaxVehiclesInChunk")) {
                                    entity.remove();
                                }
                                count++;
                            }
                        }
                    }
                }
            }, 0L, 200L);
        }

        Bukkit.getScheduler().runTaskTimer(this, () -> {
            newTotal[0] = 0;
            oldTotal[0] = 0;
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (newChunks.get(b) != null) {
                    newTotal[0] = newTotal[0] + newChunks.get(b);
                }
            });
            Bukkit.getOnlinePlayers().forEach(b -> {
                if (oldChunks.get(b) != null) {
                    oldTotal[0] = oldTotal[0] + oldChunks.get(b);
                }
            });
        }, 0L, 20L);

        if (getConfig().getBoolean("RateLimitLevers"))
            Bukkit.getScheduler().runTaskTimerAsynchronously(this, Redstone::clearLeverHashmap, 0, getConfig().getInt("RateLimitTime"));

        saveDefaultConfig();
        // Disable some config options for non 1.12 servers because they cause a shit ton of errors
        if (!getConfig().getBoolean("OverideConfigChanges")) {
            if (!Bukkit.getVersion().contains("1.12")) {
                getConfig().set("RemoveALLIllegalBlocksOnCHUNKLOAD", false);
                getConfig().set("FillInBedrockFloor", false);
                getConfig().set("FillInBedrockRoof", false);
                getConfig().set("ExperimentalDupePatch2", false);
                log.warning("Disabled:\nRemoveALLIllegalBlocksOnCHUNKLOAD\nFillInBedrockFloor\nFillInBedrockRoof\nExperimentalDupePatch2\nDue to errors with non 1.12.2 versions.");
            } else {
                getConfig().set("DisableFish", false);
                log.warning("Disabled:\nDisableFish\nbecause server is 1.12");
            }
        }
        if (getConfig().getBoolean("ExperimentalDupePatch2")) {
            Bukkit.getScheduler().runTaskTimer(this, this::preventDespawning, 0L, 20L);
        }
        log.info("[ENABLED] AnarchyExploitFixes - Made by moomoo");

        new Metrics(this, 8700);
    }

    public Integer checkChunk(Material material, Chunk c) {
        if (Bukkit.getVersion().contains("1.12") || getConfig().getBoolean("OverideConfigChanges")) {
            int count = 0;
            int cx = c.getX() << 4;
            int cz = c.getZ() << 4;

            for (int x = cx; x < cx + 16; x++) {
                for (int z = cz; z < cz + 16; z++) {
                    for (int y = 0; y < 256; y++) {
                        if (c.getBlock(x, y, z).getType() == material) {
                            count++;
                        }
                    }
                }
            }
            return count;
        }

        return 0;
    }

    public void revert(ItemStack item) {
        if (item != null) {
            // Warning: Enables a dupe exploit, reason why its disabled by default - Fix in a pr if you have time! - https://cdn.discordapp.com/attachments/810446565822038016/858851144750989312/jbIAkzJ9CU.mp4
            if (getConfig().getBoolean("LookForIllegalsInShulkers") && ItemUtil.isShulker(item)) {
                BlockStateMeta meta = (BlockStateMeta) item.getItemMeta();
                ShulkerBox box = (ShulkerBox) meta.getBlockState();

                box.getInventory().forEach(this::revert);

                box.update();
                meta.setBlockState(box);
                item.setItemMeta(meta);
            }

            if (getConfig().getBoolean("RevertStackedItems")) {
                if (getConfig().getBoolean("OnlyRevertStacksForCertainItems")) {
                    for (String s : getConfig().getStringList("RevertStackedItemsList")) {
                        if (item.getType().name().equals(s) && item.getAmount() > item.getMaxStackSize()) {
                            item.setAmount(item.getMaxStackSize());
                        }
                    }
                } else {
                    if (item.getAmount() > item.getMaxStackSize()) {
                        item.setAmount(item.getMaxStackSize());
                    }
                }
            }

            if (getConfig().getBoolean("RevertEnchantments"))
                revertEnchantments(item);

            if (getConfig().getBoolean("RemoveIllegalHeads") && item.getType().equals(Material.SKULL_ITEM)) {
                SkullMeta sm = (SkullMeta) item.getItemMeta();

                if (sm.hasOwner() || item.getData().toString().equals("SKULL_ITEM(3)")) {
                    item.subtract(item.getAmount());
                }
            }

            if (getConfig().getBoolean("RemoveSpawnEggs") && item.getItemMeta() instanceof SpawnEggMeta)
                item.subtract(item.getAmount());

            if (getConfig().getStringList("BANNED_BLOCKS").contains(item.getType().name()))
                item.subtract(item.getAmount());
        }
    }

    private void revertEnchantments(ItemStack item) {
        for (Map.Entry<Enchantment, Integer> entry : item.getEnchantments().entrySet()) {
            if (entry.getValue() != null && entry.getKey() != null) {
                if (getConfig().getBoolean("RevertSpecificEnchantments")) {
                    for (String s : getConfig().getStringList("SpecificEnchantments")) {
                        if (entry.getValue() > entry.getKey().getMaxLevel() && entry.getKey().getName().contains(s)) {
                            replaceEnchantment(item, entry.getKey(), entry.getKey().getMaxLevel());
                        }
                    }
                } else {
                    if (entry.getValue() > entry.getKey().getMaxLevel()) {
                        replaceEnchantment(item, entry.getKey(), entry.getKey().getMaxLevel());
                    }
                }
            }
        }
    }

    public void preventDespawning() {
        for (World w : Bukkit.getWorlds()) {
            for (Entity e : w.getEntities()) {
                if (e instanceof LivingEntity) {
                    ((LivingEntity) e).setRemoveWhenFarAway(!isEntityCloseToPlayer(e));
                }
            }
        }
    }

    public boolean isEntityCloseToPlayer(Entity e) {
        for (Player p : Bukkit.getOnlinePlayers()) {
            Point p1 = new Point(p.getLocation().getBlockX(), p.getLocation().getBlockZ());
            Point p2 = new Point(e.getLocation().getBlockX(), e.getLocation().getBlockZ());
            if (p1.distance(p2) < 500) {
                return true;
            }
        }
        return false;
    }

    public Integer countVehicles(Entity[] e) {
        Integer count = 0;
        for (Entity entity : e) {
            if (entity instanceof Vehicle) {
                count++;
            }
        }
        return count;
    }

    private void register(Listener... list) {
        pluginManager.registerEvents(this, this);
        for (Listener listener : list) {
            if (getConfig().getStringList("DisabledClasses").contains(listener.getClass().getSimpleName())) {
                getLogger().warning("Skipped loading class " + listener.getClass().getSimpleName() + " because disabled in config.");
            } else {
                pluginManager.registerEvents(listener, this);
                getLogger().info("Loaded class " + listener.getClass().getSimpleName());
            }
        }
    }
}
