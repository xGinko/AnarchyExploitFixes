package me.xginko.aef.utils;

import com.cryptomorin.xseries.XMaterial;
import com.cryptomorin.xseries.XTag;
import org.bukkit.Material;
import org.bukkit.SkullType;
import org.bukkit.block.BlockState;
import org.bukkit.block.Skull;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.SkullMeta;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class MaterialUtil {

    // Blocks that the player gets lowered into slightly when walking on them
    public static final Set<Material> SINK_IN_BLOCKS = Stream.of(
            XMaterial.SOUL_SAND,
            XMaterial.FARMLAND,
            XMaterial.MUD)
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PLAYER_HEADS = Stream.of(
            XMaterial.PLAYER_HEAD,
            XMaterial.PLAYER_WALL_HEAD)
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    @SuppressWarnings("deprecation")
    public static boolean isPlayerHead(BlockState blockState) {
        if (!PLAYER_HEADS.contains(blockState.getType()))
            return false;
        if (PlatformUtil.getMinecraftVersion() > 12)
            return true;
        Skull skull = (Skull) blockState;
        return skull.getSkullType() == SkullType.PLAYER || skull.hasOwner();
    }

    @SuppressWarnings("deprecation")
    public static boolean isPlayerHead(ItemStack itemStack) {
        if (!PLAYER_HEADS.contains(itemStack.getType())) {
            return false;
        }
        
        if (PlatformUtil.getMinecraftVersion() > 12) {
            return true; // Player heads have their own Material enum post 1.12.2
        }

        if (!itemStack.hasItemMeta()) {
            return false;
        }
        
        if (((SkullMeta) itemStack.getItemMeta()).hasOwner()) {
            return true;
        }

        if (itemStack.getItemMeta() instanceof BlockStateMeta) {
            BlockStateMeta blockStateMeta = (BlockStateMeta) itemStack.getItemMeta();
            return blockStateMeta.hasBlockState() && ((Skull) blockStateMeta.getBlockState()).getSkullType() == SkullType.PLAYER;
        }
        
        return false;
    }

    public static final Set<Material> SLAB_LIKE = Stream.concat(
            Arrays.stream(XMaterial.values()).filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SLAB")),
                    Stream.of(XMaterial.SCULK_SENSOR, XMaterial.CALIBRATED_SCULK_SENSOR, XMaterial.SCULK_SHRIEKER))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> REDSTONE = Stream.of(
            XMaterial.REDSTONE,
            XMaterial.REDSTONE_WIRE)
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SOLID_INDESTRUCTIBLES = Stream.of(
            XMaterial.BEDROCK,
            XMaterial.END_PORTAL_FRAME,
            XMaterial.REINFORCED_DEEPSLATE,
            XMaterial.STRUCTURE_BLOCK,
            XMaterial.STRUCTURE_VOID,
            XMaterial.BARRIER,
            XMaterial.COMMAND_BLOCK)
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> TEXT_BOOKS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("BOOK"))
            .filter(xMaterial -> xMaterial != XMaterial.ENCHANTED_BOOK)
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> INDESTRUCTIBLES = Stream.concat(
            Stream.of(XMaterial.END_PORTAL.parseMaterial()),
                    SOLID_INDESTRUCTIBLES.stream())
            .filter(Objects::nonNull)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> POTIONS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("POTION"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SHULKER_BOXES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("SHULKER_BOX"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SIGNS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SIGN"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PISTONS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("PISTON"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> TRAPDOORS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_TRAPDOOR"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> PRESSURE_PLATES = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().contains("PRESSURE_PLATE"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> ANVILS = XTag.ANVIL.getValues().stream()
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> BLOCK_DISPENSE_BUCKETS = Stream.of(
            XMaterial.WATER_BUCKET,
            XMaterial.LAVA_BUCKET,
            XMaterial.COD_BUCKET,
            XMaterial.SALMON_BUCKET,
            XMaterial.PUFFERFISH_BUCKET,
            XMaterial.TROPICAL_FISH_BUCKET,
            XMaterial.AXOLOTL_BUCKET,
            XMaterial.TADPOLE_BUCKET,
            XMaterial.POWDER_SNOW_BUCKET)
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> SPAWN_EGGS = Arrays.stream(XMaterial.values())
            .filter(xMaterial -> xMaterial.name().toUpperCase().endsWith("_SPAWN_EGG"))
            .filter(XMaterial::isSupported)
            .map(XMaterial::parseMaterial)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static final Set<Material> INVENTORY_HOLDERS = Arrays.stream(Material.values())
            .filter(Material::isItem) // Prevents loading issues in 1.20.6+
            .map(ItemStack::new)
            .filter(itemStack -> itemStack.getItemMeta() instanceof BlockStateMeta)
            .map(itemStack -> ((BlockStateMeta) itemStack.getItemMeta()).getBlockState())
            .filter(blockState -> blockState instanceof InventoryHolder)
            .map(BlockState::getType)
            .collect(Collectors.toCollection(() -> EnumSet.noneOf(Material.class)));

    public static boolean isElytra(@Nullable ItemStack itemStack) {
        return itemStack != null && itemStack.getType() == XMaterial.ELYTRA.parseMaterial();
    }
}