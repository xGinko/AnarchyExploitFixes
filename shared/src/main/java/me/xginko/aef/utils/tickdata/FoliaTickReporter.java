package me.xginko.aef.utils.tickdata;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import io.papermc.paper.threadedregions.RegionizedServer;
import io.papermc.paper.threadedregions.ThreadedRegionizer;
import io.papermc.paper.threadedregions.TickRegionScheduler;
import io.papermc.paper.threadedregions.TickRegions;
import io.papermc.paper.threadedregions.scheduler.EntityScheduler;
import io.papermc.paper.threadedregions.scheduler.RegionScheduler;
import me.xginko.aef.utils.Crafty;

import java.time.Duration;

@SuppressWarnings("DataFlowIssue")
public final class FoliaTickReporter implements TickReporter {

    private final Cache<TickRegionScheduler.RegionScheduleHandle, Double> tps_cache, mspt_cache;

    public FoliaTickReporter(Duration cacheTime) {
        this.tps_cache = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
        this.mspt_cache = Caffeine.newBuilder().expireAfterWrite(cacheTime).build();
    }

    public static boolean isSupported() {
        return      Crafty.hasClass("io.papermc.paper.threadedregions.RegionizedServer")
                &&  Crafty.hasClass("io.papermc.paper.threadedregions.ThreadedRegionizer")
                &&  Crafty.hasClass("io.papermc.paper.threadedregions.TickRegionScheduler")
                &&  Crafty.hasClass("io.papermc.paper.threadedregions.TickRegions");
    }

    @Override
    public void disable() {
        tps_cache.invalidateAll();
        tps_cache.cleanUp();
        mspt_cache.invalidateAll();
        mspt_cache.cleanUp();
    }

    @Override
    public double getGlobalTPS() {
        return tps_cache.get(RegionizedServer.getGlobalTickData(), regionScheduleHandle ->
                regionScheduleHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average());
    }

    /**
     * Please note:
     * This method needs to be called from the same thread as the region you would like to get the TPS of.
     * The recommended way of doing so is by using either the {@link RegionScheduler} or {@link EntityScheduler}.
     * It can be called from within an event as well but there's no guarantee that the TPS for the correct region
     * is returned (Read the Folia README).
     *
     * @return The TPS of the last 5 seconds from the region this method was called from, otherwise the global TPS
     */
    @Override
    public double getTPS() {
        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                region = TickRegionScheduler.getCurrentRegion();
        if (region == null)
            return getGlobalTPS();
        return tps_cache.get(region.getData().getRegionSchedulingHandle(), regionSchedulingHandle ->
                regionSchedulingHandle.getTickReport5s(System.nanoTime()).tpsData().segmentAll().average());
    }

    @Override
    public double getGlobalMSPT() {
        return mspt_cache.get(RegionizedServer.getGlobalTickData(), regionSchedulingHandle ->
                regionSchedulingHandle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average() / 1000000);
    }

    /**
     * Please note:
     * This method needs to be called from the same thread as the region you would like to get the MSPT of.
     * The recommended way of doing so is by using either the {@link RegionScheduler} or {@link EntityScheduler}.
     * It can be called from within an event as well but there's no guarantee that the MSPT for the correct region
     * is returned (Read the Folia README).
     *
     * @return The MSPT of the last 5 seconds from the region this method was called from, otherwise the global MSPT
     */
    @Override
    public double getMSPT() {
        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>
                region = TickRegionScheduler.getCurrentRegion();
        if (region == null)
            return getGlobalMSPT();
        return mspt_cache.get(region.getData().getRegionSchedulingHandle(), regionSchedulingHandle ->
                regionSchedulingHandle.getTickReport5s(System.nanoTime()).timePerTickData().segmentAll().average() / 1000000);
    }
}
