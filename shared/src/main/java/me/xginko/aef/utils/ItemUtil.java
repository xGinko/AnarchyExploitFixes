package me.xginko.aef.utils;

import com.cryptomorin.xseries.XMaterial;
import de.tr7zw.changeme.nbtapi.NBT;
import de.tr7zw.changeme.nbtapi.NbtApiException;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.minimessage.MiniMessage;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.BookMeta;
import org.bukkit.inventory.meta.BundleMeta;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.nio.charset.StandardCharsets;

public class ItemUtil {

    private static final boolean BUNDLES_SUPPPORTED, MINI_MESSAGE_SUPPORTED;

    static {
        MINI_MESSAGE_SUPPORTED
                =   Crafty.hasClass("net.kyori.adventure.text.minimessage.MiniMessage")
                &&  Crafty.hasMethod(MiniMessage.class, "miniMessage");

        BUNDLES_SUPPPORTED
                =   XMaterial.BUNDLE.isSupported()
                &&  Crafty.hasClass("org.bukkit.inventory.meta.BundleMeta");
    }

    /**
     * Gets the stored items from an ItemStack.
     *
     * @param itemStack ItemStack to check.
     * @return Iterable containing the ItemStacks stored inside the item or {@code null} if there are none.
     */
    @SuppressWarnings("UnstableApiUsage")
    public static @Nullable Iterable<ItemStack> getStoredItems(@NotNull ItemStack itemStack) {
        if (!itemStack.hasItemMeta()) {
            return null;
        }

        if (MaterialUtil.INVENTORY_HOLDER_ITEMS.contains(itemStack.getType())) {
            BlockStateMeta blockStateMeta = (BlockStateMeta) itemStack.getItemMeta();
            if (blockStateMeta.hasBlockState()) {
                return ((InventoryHolder) blockStateMeta.getBlockState()).getInventory();
            }
        }

        if (BUNDLES_SUPPPORTED && itemStack.getType() == XMaterial.BUNDLE.parseMaterial()) {
            return ((BundleMeta) itemStack.getItemMeta()).getItems();
        }

        return null;
    }

    public static int getApproximateByteSize(@Nullable ItemStack itemStack, boolean utf16) {
        if (itemStack == null || !itemStack.hasItemMeta()) {
            return 0;
        }

        Iterable<ItemStack> storedItems = getStoredItems(itemStack);
        if (storedItems != null) {
            return getApproximateByteSize(storedItems, utf16);
        }

        if (MaterialUtil.TEXT_BOOKS.contains(itemStack.getType())) {
            return getApproximateByteSize((BookMeta) itemStack.getItemMeta(), utf16);
        }

        try {
            return NBT.get(itemStack, itemNBT ->
                    itemNBT.toString().getBytes(utf16 ? StandardCharsets.UTF_16 : StandardCharsets.UTF_8).length);
        } catch (NbtApiException e) {
            return 0;
        }
    }

    public static int getApproximateByteSize(@Nullable Iterable<ItemStack> inventory, boolean utf16) {
        if (inventory == null)
            return 0;

        int collectiveSize = 0;
        for (ItemStack stack : inventory) {
            collectiveSize += getApproximateByteSize(stack, utf16);
        }

        return collectiveSize;
    }

    public static int getApproximateByteSize(@NotNull BookMeta bookMeta, boolean utf16) {
        return MINI_MESSAGE_SUPPORTED ? getApproximateByteSizeMM(bookMeta, utf16) : getApproximateByteSizeLegacy(bookMeta, utf16);
    }

    @SuppressWarnings("DataFlowIssue") // Legitimate because we make sure no values are null by testing .hasX()
    private static int getApproximateByteSizeMM(@NotNull BookMeta bookMeta, boolean utf16) {
        StringBuilder content = new StringBuilder();

        if (bookMeta.hasTitle())
            content.append(MiniMessage.miniMessage().serialize(bookMeta.title()));

        if (bookMeta.hasAuthor())
            content.append(MiniMessage.miniMessage().serialize(bookMeta.author()));

        if (bookMeta.hasPages()) {
            for (Component page : bookMeta.pages()) {
                content.append(MiniMessage.miniMessage().serialize(page));
            }
        }

        if (bookMeta.hasLore()) {
            for (Component loreLine : bookMeta.lore()) {
                content.append(MiniMessage.miniMessage().serialize(loreLine));
            }
        }

        return content.toString().getBytes(utf16 ? StandardCharsets.UTF_16 : StandardCharsets.UTF_8).length;
    }

    private static int getApproximateByteSizeLegacy(@NotNull BookMeta bookMeta, boolean utf16) {
        StringBuilder content = new StringBuilder();

        if (bookMeta.hasTitle())
            content.append(bookMeta.getTitle());

        if (bookMeta.hasAuthor())
            content.append(bookMeta.getAuthor());

        if (bookMeta.hasPages())
            bookMeta.getPages().forEach(content::append);

        if (bookMeta.hasLore())
            bookMeta.getLore().forEach(content::append);

        return content.toString().getBytes(utf16 ? StandardCharsets.UTF_16 : StandardCharsets.UTF_8).length;
    }
}
